// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.33.2
// source: auth_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "auth_service";

/** Common User Information for both users and admins */
export interface AuthUserInfo {
  userId: string;
  username: string;
  email: string;
  avatar: string;
  status: string;
  role: string;
  updatedAt: Date | undefined;
  createdAt: Date | undefined;
}

/** Pagination */
export interface PaginationRequest {
  page: number;
  pageSize: number;
}

export interface PaginationResponse {
  totalItems: number;
  totalPages: number;
}

/** Generic Error Structure */
export interface Error {
  /** e.g., "RESOURCE_NOT_FOUND", "INVALID_ARGUMENT", "UNAUTHENTICATED" */
  code: string;
  message: string;
  details: ErrorDetail[];
}

export interface ErrorDetail {
  field?: string | undefined;
  message: string;
}

/** Register User */
export interface RegisterUserRequest {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  role: string;
  avatar: string;
  /** e.g., "password", "google", "facebook" */
  authType: string;
}

export interface RegisterUserResponse {
  userId?: string | undefined;
  error?: Error | undefined;
}

/** OAuth2 Sign */
export interface Auth2SignRequest {
  token: string;
  provider: string;
  authType: string;
}

export interface Auth2SignResponse {
  success?: AuthUserResponse | undefined;
  error?: Error | undefined;
}

/** User Login/Logout */
export interface LoginUserRequest {
  email: string;
  password: string;
  rememberMe: boolean;
}

export interface LoginUserResponse {
  success?: AuthUserResponse | undefined;
  error?: Error | undefined;
}

export interface LogoutUserRequest {
  userId: string;
}

export interface LogoutResponse {
  userId: string;
  message: string;
}

export interface LogoutUserResponse {
  success?: LogoutResponse | undefined;
  error?: Error | undefined;
}

/** User Verification */
export interface VerifyUserRequest {
  email: string;
}

export interface VerifyUserResponse {
  success?: AuthUserResponse | undefined;
  error?: Error | undefined;
}

/** AuthUser/Instructor Responses */
export interface AuthUserResponse {
  accessToken: string;
  refreshToken: string;
}

export interface InstructorSuccessResponse {
  accessToken: string;
  refreshToken: string;
}

export interface RegisterInstructorRequest {
  userId: string;
}

export interface RegisterInstructorResponse {
  error?: Error | undefined;
  success?: InstructorSuccessResponse | undefined;
}

/** Token Refresh */
export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  success?: RefreshSuccess | undefined;
  error?: Error | undefined;
}

export interface RefreshSuccess {
  accessToken: string;
  refreshToken: string;
}

/** Admin Login */
export interface AdminLoginRequest {
  email: string;
  password: string;
}

export interface AdminLoginResponse {
  success?: AdminAuthSuccess | undefined;
  error?: Error | undefined;
}

export interface AdminAuthSuccess {
  accessToken: string;
  refreshToken: string;
}

/** Admin Refresh Token */
export interface AdminRefreshRequest {
  refreshToken: string;
}

export interface AdminRefreshResponse {
  success?: AdminRefreshSuccess | undefined;
  error?: Error | undefined;
}

export interface AdminRefreshSuccess {
  accessToken: string;
  refreshToken: string;
}

/** Forgot Password */
export interface ForgotPasswordRequest {
  email: string;
}

export interface ForgotPasswordResponse {
  success?: ForgotPasswordSuccess | undefined;
  error?: Error | undefined;
}

export interface ForgotPasswordSuccess {
  username: string;
  userId: string;
  email: string;
  /** int32 expires = 4; */
  resetLink: string;
}

/** Change Password */
export interface ChangePasswordRequest {
  userId: string;
  oldPassword: string;
  newPassword: string;
}

export interface ChangePasswordResponse {
  success?: ChangePasswordSuccess | undefined;
  error?: Error | undefined;
}

export interface ChangePasswordSuccess {
  updated: boolean;
}

/** Reset Password */
export interface ResetPasswordRequest {
  token: string;
  password: string;
  confirmPassword: string;
}

export interface ResetPasswordResponse {
  success?: ResetPasswordSuccess | undefined;
  error?: Error | undefined;
}

export interface ResetPasswordSuccess {
  updated: boolean;
}

/** Check Email Existence */
export interface CheckUserByEmailRequest {
  email: string;
}

export interface EmailExist {
  success: string;
  error: string;
}

export interface CheckUserByEmailResponse {
  response?: EmailExist | undefined;
  error?: Error | undefined;
}

/** Block/Unblock User */
export interface BlockUserRequest {
  userId: string;
}

export interface UnBlockUserRequest {
  userId: string;
}

export interface BlockUserResponse {
  success?: BlockUserSuccess | undefined;
  error?: Error | undefined;
}

export interface UnBlockUserResponse {
  success?: UnBlockUserSuccess | undefined;
  error?: Error | undefined;
}

export interface BlockUserSuccess {
  updated: boolean;
}

export interface UnBlockUserSuccess {
  updated: boolean;
}

function createBaseAuthUserInfo(): AuthUserInfo {
  return {
    userId: "",
    username: "",
    email: "",
    avatar: "",
    status: "",
    role: "",
    updatedAt: undefined,
    createdAt: undefined,
  };
}

export const AuthUserInfo: MessageFns<AuthUserInfo> = {
  encode(message: AuthUserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.avatar !== "") {
      writer.uint32(34).string(message.avatar);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.role !== "") {
      writer.uint32(50).string(message.role);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthUserInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: AuthUserInfo): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthUserInfo>, I>>(base?: I): AuthUserInfo {
    return AuthUserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthUserInfo>, I>>(object: I): AuthUserInfo {
    const message = createBaseAuthUserInfo();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.avatar = object.avatar ?? "";
    message.status = object.status ?? "";
    message.role = object.role ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { page: 0, pageSize: 0 };
}

export const PaginationRequest: MessageFns<PaginationRequest> = {
  encode(message: PaginationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: PaginationRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationRequest>, I>>(base?: I): PaginationRequest {
    return PaginationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationRequest>, I>>(object: I): PaginationRequest {
    const message = createBasePaginationRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { totalItems: 0, totalPages: 0 };
}

export const PaginationResponse: MessageFns<PaginationResponse> = {
  encode(message: PaginationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalItems !== 0) {
      writer.uint32(8).int32(message.totalItems);
    }
    if (message.totalPages !== 0) {
      writer.uint32(16).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResponse {
    return {
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: PaginationResponse): unknown {
    const obj: any = {};
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResponse>, I>>(base?: I): PaginationResponse {
    return PaginationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResponse>, I>>(object: I): PaginationResponse {
    const message = createBasePaginationResponse();
    message.totalItems = object.totalItems ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseError(): Error {
  return { code: "", message: "", details: [] };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.details) {
      ErrorDetail.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: globalThis.Array.isArray(object?.details) ? object.details.map((e: any) => ErrorDetail.fromJSON(e)) : [],
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => ErrorDetail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.details = object.details?.map((e) => ErrorDetail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseErrorDetail(): ErrorDetail {
  return { field: undefined, message: "" };
}

export const ErrorDetail: MessageFns<ErrorDetail> = {
  encode(message: ErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined) {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorDetail {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ErrorDetail): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = message.field;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorDetail>, I>>(base?: I): ErrorDetail {
    return ErrorDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorDetail>, I>>(object: I): ErrorDetail {
    const message = createBaseErrorDetail();
    message.field = object.field ?? undefined;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseRegisterUserRequest(): RegisterUserRequest {
  return { firstName: "", lastName: "", email: "", password: "", role: "", avatar: "", authType: "" };
}

export const RegisterUserRequest: MessageFns<RegisterUserRequest> = {
  encode(message: RegisterUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstName !== "") {
      writer.uint32(10).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(58).string(message.lastName);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    if (message.avatar !== "") {
      writer.uint32(42).string(message.avatar);
    }
    if (message.authType !== "") {
      writer.uint32(50).string(message.authType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.authType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserRequest {
    return {
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      authType: isSet(object.authType) ? globalThis.String(object.authType) : "",
    };
  },

  toJSON(message: RegisterUserRequest): unknown {
    const obj: any = {};
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.authType !== "") {
      obj.authType = message.authType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(base?: I): RegisterUserRequest {
    return RegisterUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(object: I): RegisterUserRequest {
    const message = createBaseRegisterUserRequest();
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.role = object.role ?? "";
    message.avatar = object.avatar ?? "";
    message.authType = object.authType ?? "";
    return message;
  },
};

function createBaseRegisterUserResponse(): RegisterUserResponse {
  return { userId: undefined, error: undefined };
}

export const RegisterUserResponse: MessageFns<RegisterUserResponse> = {
  encode(message: RegisterUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== undefined) {
      writer.uint32(10).string(message.userId);
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: RegisterUserResponse): unknown {
    const obj: any = {};
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(base?: I): RegisterUserResponse {
    return RegisterUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(object: I): RegisterUserResponse {
    const message = createBaseRegisterUserResponse();
    message.userId = object.userId ?? undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseAuth2SignRequest(): Auth2SignRequest {
  return { token: "", provider: "", authType: "" };
}

export const Auth2SignRequest: MessageFns<Auth2SignRequest> = {
  encode(message: Auth2SignRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.provider !== "") {
      writer.uint32(18).string(message.provider);
    }
    if (message.authType !== "") {
      writer.uint32(26).string(message.authType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Auth2SignRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuth2SignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Auth2SignRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      authType: isSet(object.authType) ? globalThis.String(object.authType) : "",
    };
  },

  toJSON(message: Auth2SignRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.authType !== "") {
      obj.authType = message.authType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Auth2SignRequest>, I>>(base?: I): Auth2SignRequest {
    return Auth2SignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Auth2SignRequest>, I>>(object: I): Auth2SignRequest {
    const message = createBaseAuth2SignRequest();
    message.token = object.token ?? "";
    message.provider = object.provider ?? "";
    message.authType = object.authType ?? "";
    return message;
  },
};

function createBaseAuth2SignResponse(): Auth2SignResponse {
  return { success: undefined, error: undefined };
}

export const Auth2SignResponse: MessageFns<Auth2SignResponse> = {
  encode(message: Auth2SignResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AuthUserResponse.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Auth2SignResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuth2SignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AuthUserResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Auth2SignResponse {
    return {
      success: isSet(object.success) ? AuthUserResponse.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: Auth2SignResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AuthUserResponse.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Auth2SignResponse>, I>>(base?: I): Auth2SignResponse {
    return Auth2SignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Auth2SignResponse>, I>>(object: I): Auth2SignResponse {
    const message = createBaseAuth2SignResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? AuthUserResponse.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseLoginUserRequest(): LoginUserRequest {
  return { email: "", password: "", rememberMe: false };
}

export const LoginUserRequest: MessageFns<LoginUserRequest> = {
  encode(message: LoginUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.rememberMe !== false) {
      writer.uint32(24).bool(message.rememberMe);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rememberMe = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginUserRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      rememberMe: isSet(object.rememberMe) ? globalThis.Boolean(object.rememberMe) : false,
    };
  },

  toJSON(message: LoginUserRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.rememberMe !== false) {
      obj.rememberMe = message.rememberMe;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginUserRequest>, I>>(base?: I): LoginUserRequest {
    return LoginUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginUserRequest>, I>>(object: I): LoginUserRequest {
    const message = createBaseLoginUserRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.rememberMe = object.rememberMe ?? false;
    return message;
  },
};

function createBaseLoginUserResponse(): LoginUserResponse {
  return { success: undefined, error: undefined };
}

export const LoginUserResponse: MessageFns<LoginUserResponse> = {
  encode(message: LoginUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AuthUserResponse.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AuthUserResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginUserResponse {
    return {
      success: isSet(object.success) ? AuthUserResponse.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: LoginUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AuthUserResponse.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginUserResponse>, I>>(base?: I): LoginUserResponse {
    return LoginUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginUserResponse>, I>>(object: I): LoginUserResponse {
    const message = createBaseLoginUserResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? AuthUserResponse.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseLogoutUserRequest(): LogoutUserRequest {
  return { userId: "" };
}

export const LogoutUserRequest: MessageFns<LogoutUserRequest> = {
  encode(message: LogoutUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: LogoutUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutUserRequest>, I>>(base?: I): LogoutUserRequest {
    return LogoutUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutUserRequest>, I>>(object: I): LogoutUserRequest {
    const message = createBaseLogoutUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseLogoutResponse(): LogoutResponse {
  return { userId: "", message: "" };
}

export const LogoutResponse: MessageFns<LogoutResponse> = {
  encode(message: LogoutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: LogoutResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutResponse>, I>>(base?: I): LogoutResponse {
    return LogoutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutResponse>, I>>(object: I): LogoutResponse {
    const message = createBaseLogoutResponse();
    message.userId = object.userId ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseLogoutUserResponse(): LogoutUserResponse {
  return { success: undefined, error: undefined };
}

export const LogoutUserResponse: MessageFns<LogoutUserResponse> = {
  encode(message: LogoutUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      LogoutResponse.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = LogoutResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutUserResponse {
    return {
      success: isSet(object.success) ? LogoutResponse.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: LogoutUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = LogoutResponse.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutUserResponse>, I>>(base?: I): LogoutUserResponse {
    return LogoutUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutUserResponse>, I>>(object: I): LogoutUserResponse {
    const message = createBaseLogoutUserResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? LogoutResponse.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseVerifyUserRequest(): VerifyUserRequest {
  return { email: "" };
}

export const VerifyUserRequest: MessageFns<VerifyUserRequest> = {
  encode(message: VerifyUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyUserRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: VerifyUserRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyUserRequest>, I>>(base?: I): VerifyUserRequest {
    return VerifyUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyUserRequest>, I>>(object: I): VerifyUserRequest {
    const message = createBaseVerifyUserRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseVerifyUserResponse(): VerifyUserResponse {
  return { success: undefined, error: undefined };
}

export const VerifyUserResponse: MessageFns<VerifyUserResponse> = {
  encode(message: VerifyUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AuthUserResponse.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AuthUserResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyUserResponse {
    return {
      success: isSet(object.success) ? AuthUserResponse.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: VerifyUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AuthUserResponse.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyUserResponse>, I>>(base?: I): VerifyUserResponse {
    return VerifyUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyUserResponse>, I>>(object: I): VerifyUserResponse {
    const message = createBaseVerifyUserResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? AuthUserResponse.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseAuthUserResponse(): AuthUserResponse {
  return { accessToken: "", refreshToken: "" };
}

export const AuthUserResponse: MessageFns<AuthUserResponse> = {
  encode(message: AuthUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthUserResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: AuthUserResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthUserResponse>, I>>(base?: I): AuthUserResponse {
    return AuthUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthUserResponse>, I>>(object: I): AuthUserResponse {
    const message = createBaseAuthUserResponse();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseInstructorSuccessResponse(): InstructorSuccessResponse {
  return { accessToken: "", refreshToken: "" };
}

export const InstructorSuccessResponse: MessageFns<InstructorSuccessResponse> = {
  encode(message: InstructorSuccessResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstructorSuccessResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstructorSuccessResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstructorSuccessResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: InstructorSuccessResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstructorSuccessResponse>, I>>(base?: I): InstructorSuccessResponse {
    return InstructorSuccessResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstructorSuccessResponse>, I>>(object: I): InstructorSuccessResponse {
    const message = createBaseInstructorSuccessResponse();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseRegisterInstructorRequest(): RegisterInstructorRequest {
  return { userId: "" };
}

export const RegisterInstructorRequest: MessageFns<RegisterInstructorRequest> = {
  encode(message: RegisterInstructorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterInstructorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterInstructorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterInstructorRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: RegisterInstructorRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterInstructorRequest>, I>>(base?: I): RegisterInstructorRequest {
    return RegisterInstructorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterInstructorRequest>, I>>(object: I): RegisterInstructorRequest {
    const message = createBaseRegisterInstructorRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseRegisterInstructorResponse(): RegisterInstructorResponse {
  return { error: undefined, success: undefined };
}

export const RegisterInstructorResponse: MessageFns<RegisterInstructorResponse> = {
  encode(message: RegisterInstructorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(10).fork()).join();
    }
    if (message.success !== undefined) {
      InstructorSuccessResponse.encode(message.success, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterInstructorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterInstructorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.success = InstructorSuccessResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterInstructorResponse {
    return {
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      success: isSet(object.success) ? InstructorSuccessResponse.fromJSON(object.success) : undefined,
    };
  },

  toJSON(message: RegisterInstructorResponse): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.success !== undefined) {
      obj.success = InstructorSuccessResponse.toJSON(message.success);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterInstructorResponse>, I>>(base?: I): RegisterInstructorResponse {
    return RegisterInstructorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterInstructorResponse>, I>>(object: I): RegisterInstructorResponse {
    const message = createBaseRegisterInstructorResponse();
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.success = (object.success !== undefined && object.success !== null)
      ? InstructorSuccessResponse.fromPartial(object.success)
      : undefined;
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(object: I): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseRefreshTokenResponse(): RefreshTokenResponse {
  return { success: undefined, error: undefined };
}

export const RefreshTokenResponse: MessageFns<RefreshTokenResponse> = {
  encode(message: RefreshTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      RefreshSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = RefreshSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenResponse {
    return {
      success: isSet(object.success) ? RefreshSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: RefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = RefreshSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(base?: I): RefreshTokenResponse {
    return RefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(object: I): RefreshTokenResponse {
    const message = createBaseRefreshTokenResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? RefreshSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseRefreshSuccess(): RefreshSuccess {
  return { accessToken: "", refreshToken: "" };
}

export const RefreshSuccess: MessageFns<RefreshSuccess> = {
  encode(message: RefreshSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshSuccess {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: RefreshSuccess): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshSuccess>, I>>(base?: I): RefreshSuccess {
    return RefreshSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshSuccess>, I>>(object: I): RefreshSuccess {
    const message = createBaseRefreshSuccess();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseAdminLoginRequest(): AdminLoginRequest {
  return { email: "", password: "" };
}

export const AdminLoginRequest: MessageFns<AdminLoginRequest> = {
  encode(message: AdminLoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminLoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminLoginRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: AdminLoginRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminLoginRequest>, I>>(base?: I): AdminLoginRequest {
    return AdminLoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminLoginRequest>, I>>(object: I): AdminLoginRequest {
    const message = createBaseAdminLoginRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseAdminLoginResponse(): AdminLoginResponse {
  return { success: undefined, error: undefined };
}

export const AdminLoginResponse: MessageFns<AdminLoginResponse> = {
  encode(message: AdminLoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AdminAuthSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminLoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AdminAuthSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminLoginResponse {
    return {
      success: isSet(object.success) ? AdminAuthSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: AdminLoginResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AdminAuthSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminLoginResponse>, I>>(base?: I): AdminLoginResponse {
    return AdminLoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminLoginResponse>, I>>(object: I): AdminLoginResponse {
    const message = createBaseAdminLoginResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? AdminAuthSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseAdminAuthSuccess(): AdminAuthSuccess {
  return { accessToken: "", refreshToken: "" };
}

export const AdminAuthSuccess: MessageFns<AdminAuthSuccess> = {
  encode(message: AdminAuthSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminAuthSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminAuthSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminAuthSuccess {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: AdminAuthSuccess): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminAuthSuccess>, I>>(base?: I): AdminAuthSuccess {
    return AdminAuthSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminAuthSuccess>, I>>(object: I): AdminAuthSuccess {
    const message = createBaseAdminAuthSuccess();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseAdminRefreshRequest(): AdminRefreshRequest {
  return { refreshToken: "" };
}

export const AdminRefreshRequest: MessageFns<AdminRefreshRequest> = {
  encode(message: AdminRefreshRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminRefreshRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminRefreshRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminRefreshRequest {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: AdminRefreshRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminRefreshRequest>, I>>(base?: I): AdminRefreshRequest {
    return AdminRefreshRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminRefreshRequest>, I>>(object: I): AdminRefreshRequest {
    const message = createBaseAdminRefreshRequest();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseAdminRefreshResponse(): AdminRefreshResponse {
  return { success: undefined, error: undefined };
}

export const AdminRefreshResponse: MessageFns<AdminRefreshResponse> = {
  encode(message: AdminRefreshResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AdminRefreshSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminRefreshResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminRefreshResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AdminRefreshSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminRefreshResponse {
    return {
      success: isSet(object.success) ? AdminRefreshSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: AdminRefreshResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AdminRefreshSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminRefreshResponse>, I>>(base?: I): AdminRefreshResponse {
    return AdminRefreshResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminRefreshResponse>, I>>(object: I): AdminRefreshResponse {
    const message = createBaseAdminRefreshResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? AdminRefreshSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseAdminRefreshSuccess(): AdminRefreshSuccess {
  return { accessToken: "", refreshToken: "" };
}

export const AdminRefreshSuccess: MessageFns<AdminRefreshSuccess> = {
  encode(message: AdminRefreshSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminRefreshSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminRefreshSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdminRefreshSuccess {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: AdminRefreshSuccess): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdminRefreshSuccess>, I>>(base?: I): AdminRefreshSuccess {
    return AdminRefreshSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminRefreshSuccess>, I>>(object: I): AdminRefreshSuccess {
    const message = createBaseAdminRefreshSuccess();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { email: "" };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(message: ForgotPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(base?: I): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(object: I): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseForgotPasswordResponse(): ForgotPasswordResponse {
  return { success: undefined, error: undefined };
}

export const ForgotPasswordResponse: MessageFns<ForgotPasswordResponse> = {
  encode(message: ForgotPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      ForgotPasswordSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = ForgotPasswordSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordResponse {
    return {
      success: isSet(object.success) ? ForgotPasswordSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ForgotPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = ForgotPasswordSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(base?: I): ForgotPasswordResponse {
    return ForgotPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(object: I): ForgotPasswordResponse {
    const message = createBaseForgotPasswordResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? ForgotPasswordSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseForgotPasswordSuccess(): ForgotPasswordSuccess {
  return { username: "", userId: "", email: "", resetLink: "" };
}

export const ForgotPasswordSuccess: MessageFns<ForgotPasswordSuccess> = {
  encode(message: ForgotPasswordSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.userId !== "") {
      writer.uint32(42).string(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.resetLink !== "") {
      writer.uint32(26).string(message.resetLink);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resetLink = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordSuccess {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      resetLink: isSet(object.resetLink) ? globalThis.String(object.resetLink) : "",
    };
  },

  toJSON(message: ForgotPasswordSuccess): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.resetLink !== "") {
      obj.resetLink = message.resetLink;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordSuccess>, I>>(base?: I): ForgotPasswordSuccess {
    return ForgotPasswordSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordSuccess>, I>>(object: I): ForgotPasswordSuccess {
    const message = createBaseForgotPasswordSuccess();
    message.username = object.username ?? "";
    message.userId = object.userId ?? "";
    message.email = object.email ?? "";
    message.resetLink = object.resetLink ?? "";
    return message;
  },
};

function createBaseChangePasswordRequest(): ChangePasswordRequest {
  return { userId: "", oldPassword: "", newPassword: "" };
}

export const ChangePasswordRequest: MessageFns<ChangePasswordRequest> = {
  encode(message: ChangePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.oldPassword !== "") {
      writer.uint32(18).string(message.oldPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(26).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      oldPassword: isSet(object.oldPassword) ? globalThis.String(object.oldPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ChangePasswordRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.oldPassword !== "") {
      obj.oldPassword = message.oldPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(base?: I): ChangePasswordRequest {
    return ChangePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(object: I): ChangePasswordRequest {
    const message = createBaseChangePasswordRequest();
    message.userId = object.userId ?? "";
    message.oldPassword = object.oldPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseChangePasswordResponse(): ChangePasswordResponse {
  return { success: undefined, error: undefined };
}

export const ChangePasswordResponse: MessageFns<ChangePasswordResponse> = {
  encode(message: ChangePasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      ChangePasswordSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = ChangePasswordSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordResponse {
    return {
      success: isSet(object.success) ? ChangePasswordSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ChangePasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = ChangePasswordSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordResponse>, I>>(base?: I): ChangePasswordResponse {
    return ChangePasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordResponse>, I>>(object: I): ChangePasswordResponse {
    const message = createBaseChangePasswordResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? ChangePasswordSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseChangePasswordSuccess(): ChangePasswordSuccess {
  return { updated: false };
}

export const ChangePasswordSuccess: MessageFns<ChangePasswordSuccess> = {
  encode(message: ChangePasswordSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: ChangePasswordSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordSuccess>, I>>(base?: I): ChangePasswordSuccess {
    return ChangePasswordSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordSuccess>, I>>(object: I): ChangePasswordSuccess {
    const message = createBaseChangePasswordSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { token: "", password: "", confirmPassword: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.confirmPassword !== "") {
      writer.uint32(26).string(message.confirmPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.confirmPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      confirmPassword: isSet(object.confirmPassword) ? globalThis.String(object.confirmPassword) : "",
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.confirmPassword !== "") {
      obj.confirmPassword = message.confirmPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(base?: I): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(object: I): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.token = object.token ?? "";
    message.password = object.password ?? "";
    message.confirmPassword = object.confirmPassword ?? "";
    return message;
  },
};

function createBaseResetPasswordResponse(): ResetPasswordResponse {
  return { success: undefined, error: undefined };
}

export const ResetPasswordResponse: MessageFns<ResetPasswordResponse> = {
  encode(message: ResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      ResetPasswordSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = ResetPasswordSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordResponse {
    return {
      success: isSet(object.success) ? ResetPasswordSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = ResetPasswordSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(base?: I): ResetPasswordResponse {
    return ResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(object: I): ResetPasswordResponse {
    const message = createBaseResetPasswordResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? ResetPasswordSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseResetPasswordSuccess(): ResetPasswordSuccess {
  return { updated: false };
}

export const ResetPasswordSuccess: MessageFns<ResetPasswordSuccess> = {
  encode(message: ResetPasswordSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: ResetPasswordSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordSuccess>, I>>(base?: I): ResetPasswordSuccess {
    return ResetPasswordSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordSuccess>, I>>(object: I): ResetPasswordSuccess {
    const message = createBaseResetPasswordSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

function createBaseCheckUserByEmailRequest(): CheckUserByEmailRequest {
  return { email: "" };
}

export const CheckUserByEmailRequest: MessageFns<CheckUserByEmailRequest> = {
  encode(message: CheckUserByEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUserByEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUserByEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUserByEmailRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: CheckUserByEmailRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckUserByEmailRequest>, I>>(base?: I): CheckUserByEmailRequest {
    return CheckUserByEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckUserByEmailRequest>, I>>(object: I): CheckUserByEmailRequest {
    const message = createBaseCheckUserByEmailRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseEmailExist(): EmailExist {
  return { success: "", error: "" };
}

export const EmailExist: MessageFns<EmailExist> = {
  encode(message: EmailExist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== "") {
      writer.uint32(10).string(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailExist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailExist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailExist {
    return {
      success: isSet(object.success) ? globalThis.String(object.success) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: EmailExist): unknown {
    const obj: any = {};
    if (message.success !== "") {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailExist>, I>>(base?: I): EmailExist {
    return EmailExist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailExist>, I>>(object: I): EmailExist {
    const message = createBaseEmailExist();
    message.success = object.success ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCheckUserByEmailResponse(): CheckUserByEmailResponse {
  return { response: undefined, error: undefined };
}

export const CheckUserByEmailResponse: MessageFns<CheckUserByEmailResponse> = {
  encode(message: CheckUserByEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      EmailExist.encode(message.response, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUserByEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUserByEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = EmailExist.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUserByEmailResponse {
    return {
      response: isSet(object.response) ? EmailExist.fromJSON(object.response) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: CheckUserByEmailResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = EmailExist.toJSON(message.response);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckUserByEmailResponse>, I>>(base?: I): CheckUserByEmailResponse {
    return CheckUserByEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckUserByEmailResponse>, I>>(object: I): CheckUserByEmailResponse {
    const message = createBaseCheckUserByEmailResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? EmailExist.fromPartial(object.response)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseBlockUserRequest(): BlockUserRequest {
  return { userId: "" };
}

export const BlockUserRequest: MessageFns<BlockUserRequest> = {
  encode(message: BlockUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: BlockUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserRequest>, I>>(base?: I): BlockUserRequest {
    return BlockUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserRequest>, I>>(object: I): BlockUserRequest {
    const message = createBaseBlockUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseUnBlockUserRequest(): UnBlockUserRequest {
  return { userId: "" };
}

export const UnBlockUserRequest: MessageFns<UnBlockUserRequest> = {
  encode(message: UnBlockUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnBlockUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnBlockUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: UnBlockUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnBlockUserRequest>, I>>(base?: I): UnBlockUserRequest {
    return UnBlockUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnBlockUserRequest>, I>>(object: I): UnBlockUserRequest {
    const message = createBaseUnBlockUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseBlockUserResponse(): BlockUserResponse {
  return { success: undefined, error: undefined };
}

export const BlockUserResponse: MessageFns<BlockUserResponse> = {
  encode(message: BlockUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      BlockUserSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = BlockUserSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserResponse {
    return {
      success: isSet(object.success) ? BlockUserSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BlockUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = BlockUserSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserResponse>, I>>(base?: I): BlockUserResponse {
    return BlockUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserResponse>, I>>(object: I): BlockUserResponse {
    const message = createBaseBlockUserResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? BlockUserSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseUnBlockUserResponse(): UnBlockUserResponse {
  return { success: undefined, error: undefined };
}

export const UnBlockUserResponse: MessageFns<UnBlockUserResponse> = {
  encode(message: UnBlockUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      UnBlockUserSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnBlockUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnBlockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = UnBlockUserSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnBlockUserResponse {
    return {
      success: isSet(object.success) ? UnBlockUserSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: UnBlockUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = UnBlockUserSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnBlockUserResponse>, I>>(base?: I): UnBlockUserResponse {
    return UnBlockUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnBlockUserResponse>, I>>(object: I): UnBlockUserResponse {
    const message = createBaseUnBlockUserResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? UnBlockUserSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseBlockUserSuccess(): BlockUserSuccess {
  return { updated: false };
}

export const BlockUserSuccess: MessageFns<BlockUserSuccess> = {
  encode(message: BlockUserSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: BlockUserSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserSuccess>, I>>(base?: I): BlockUserSuccess {
    return BlockUserSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserSuccess>, I>>(object: I): BlockUserSuccess {
    const message = createBaseBlockUserSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

function createBaseUnBlockUserSuccess(): UnBlockUserSuccess {
  return { updated: false };
}

export const UnBlockUserSuccess: MessageFns<UnBlockUserSuccess> = {
  encode(message: UnBlockUserSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnBlockUserSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnBlockUserSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnBlockUserSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: UnBlockUserSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnBlockUserSuccess>, I>>(base?: I): UnBlockUserSuccess {
    return UnBlockUserSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnBlockUserSuccess>, I>>(object: I): UnBlockUserSuccess {
    const message = createBaseUnBlockUserSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  /** User endpoints */
  registerUser: {
    path: "/auth_service.AuthService/RegisterUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterUserRequest) => Buffer.from(RegisterUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegisterUserRequest.decode(value),
    responseSerialize: (value: RegisterUserResponse) => Buffer.from(RegisterUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RegisterUserResponse.decode(value),
  },
  auth2Sign: {
    path: "/auth_service.AuthService/Auth2Sign",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Auth2SignRequest) => Buffer.from(Auth2SignRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Auth2SignRequest.decode(value),
    responseSerialize: (value: Auth2SignResponse) => Buffer.from(Auth2SignResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Auth2SignResponse.decode(value),
  },
  verifyUser: {
    path: "/auth_service.AuthService/VerifyUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyUserRequest) => Buffer.from(VerifyUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyUserRequest.decode(value),
    responseSerialize: (value: VerifyUserResponse) => Buffer.from(VerifyUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyUserResponse.decode(value),
  },
  loginUser: {
    path: "/auth_service.AuthService/LoginUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginUserRequest) => Buffer.from(LoginUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LoginUserRequest.decode(value),
    responseSerialize: (value: LoginUserResponse) => Buffer.from(LoginUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LoginUserResponse.decode(value),
  },
  logoutUser: {
    path: "/auth_service.AuthService/LogoutUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LogoutUserRequest) => Buffer.from(LogoutUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LogoutUserRequest.decode(value),
    responseSerialize: (value: LogoutUserResponse) => Buffer.from(LogoutUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LogoutUserResponse.decode(value),
  },
  refreshToken: {
    path: "/auth_service.AuthService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest) => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RefreshTokenRequest.decode(value),
    responseSerialize: (value: RefreshTokenResponse) => Buffer.from(RefreshTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RefreshTokenResponse.decode(value),
  },
  forgotPassword: {
    path: "/auth_service.AuthService/ForgotPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest) => Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: ForgotPasswordResponse) => Buffer.from(ForgotPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ForgotPasswordResponse.decode(value),
  },
  changePassword: {
    path: "/auth_service.AuthService/ChangePassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChangePasswordRequest) => Buffer.from(ChangePasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChangePasswordRequest.decode(value),
    responseSerialize: (value: ChangePasswordResponse) => Buffer.from(ChangePasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ChangePasswordResponse.decode(value),
  },
  resetPassword: {
    path: "/auth_service.AuthService/ResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest) => Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ResetPasswordRequest.decode(value),
    responseSerialize: (value: ResetPasswordResponse) => Buffer.from(ResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ResetPasswordResponse.decode(value),
  },
  blockUser: {
    path: "/auth_service.AuthService/BlockUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockUserRequest) => Buffer.from(BlockUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockUserRequest.decode(value),
    responseSerialize: (value: BlockUserResponse) => Buffer.from(BlockUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockUserResponse.decode(value),
  },
  unBlockUser: {
    path: "/auth_service.AuthService/UnBlockUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnBlockUserRequest) => Buffer.from(UnBlockUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UnBlockUserRequest.decode(value),
    responseSerialize: (value: UnBlockUserResponse) => Buffer.from(UnBlockUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UnBlockUserResponse.decode(value),
  },
  /** --- New: Admin Auth Endpoints --- */
  adminLogin: {
    path: "/auth_service.AuthService/AdminLogin",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdminLoginRequest) => Buffer.from(AdminLoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AdminLoginRequest.decode(value),
    responseSerialize: (value: AdminLoginResponse) => Buffer.from(AdminLoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AdminLoginResponse.decode(value),
  },
  adminRefresh: {
    path: "/auth_service.AuthService/AdminRefresh",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdminRefreshRequest) => Buffer.from(AdminRefreshRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AdminRefreshRequest.decode(value),
    responseSerialize: (value: AdminRefreshResponse) => Buffer.from(AdminRefreshResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AdminRefreshResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  /** User endpoints */
  registerUser: handleUnaryCall<RegisterUserRequest, RegisterUserResponse>;
  auth2Sign: handleUnaryCall<Auth2SignRequest, Auth2SignResponse>;
  verifyUser: handleUnaryCall<VerifyUserRequest, VerifyUserResponse>;
  loginUser: handleUnaryCall<LoginUserRequest, LoginUserResponse>;
  logoutUser: handleUnaryCall<LogoutUserRequest, LogoutUserResponse>;
  refreshToken: handleUnaryCall<RefreshTokenRequest, RefreshTokenResponse>;
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, ForgotPasswordResponse>;
  changePassword: handleUnaryCall<ChangePasswordRequest, ChangePasswordResponse>;
  resetPassword: handleUnaryCall<ResetPasswordRequest, ResetPasswordResponse>;
  blockUser: handleUnaryCall<BlockUserRequest, BlockUserResponse>;
  unBlockUser: handleUnaryCall<UnBlockUserRequest, UnBlockUserResponse>;
  /** --- New: Admin Auth Endpoints --- */
  adminLogin: handleUnaryCall<AdminLoginRequest, AdminLoginResponse>;
  adminRefresh: handleUnaryCall<AdminRefreshRequest, AdminRefreshResponse>;
}

export interface AuthServiceClient extends Client {
  /** User endpoints */
  registerUser(
    request: RegisterUserRequest,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  auth2Sign(
    request: Auth2SignRequest,
    callback: (error: ServiceError | null, response: Auth2SignResponse) => void,
  ): ClientUnaryCall;
  auth2Sign(
    request: Auth2SignRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Auth2SignResponse) => void,
  ): ClientUnaryCall;
  auth2Sign(
    request: Auth2SignRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Auth2SignResponse) => void,
  ): ClientUnaryCall;
  verifyUser(
    request: VerifyUserRequest,
    callback: (error: ServiceError | null, response: VerifyUserResponse) => void,
  ): ClientUnaryCall;
  verifyUser(
    request: VerifyUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyUserResponse) => void,
  ): ClientUnaryCall;
  verifyUser(
    request: VerifyUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  logoutUser(
    request: LogoutUserRequest,
    callback: (error: ServiceError | null, response: LogoutUserResponse) => void,
  ): ClientUnaryCall;
  logoutUser(
    request: LogoutUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LogoutUserResponse) => void,
  ): ClientUnaryCall;
  logoutUser(
    request: LogoutUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LogoutUserResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  blockUser(
    request: BlockUserRequest,
    callback: (error: ServiceError | null, response: BlockUserResponse) => void,
  ): ClientUnaryCall;
  blockUser(
    request: BlockUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockUserResponse) => void,
  ): ClientUnaryCall;
  blockUser(
    request: BlockUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockUserResponse) => void,
  ): ClientUnaryCall;
  unBlockUser(
    request: UnBlockUserRequest,
    callback: (error: ServiceError | null, response: UnBlockUserResponse) => void,
  ): ClientUnaryCall;
  unBlockUser(
    request: UnBlockUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UnBlockUserResponse) => void,
  ): ClientUnaryCall;
  unBlockUser(
    request: UnBlockUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UnBlockUserResponse) => void,
  ): ClientUnaryCall;
  /** --- New: Admin Auth Endpoints --- */
  adminLogin(
    request: AdminLoginRequest,
    callback: (error: ServiceError | null, response: AdminLoginResponse) => void,
  ): ClientUnaryCall;
  adminLogin(
    request: AdminLoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AdminLoginResponse) => void,
  ): ClientUnaryCall;
  adminLogin(
    request: AdminLoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AdminLoginResponse) => void,
  ): ClientUnaryCall;
  adminRefresh(
    request: AdminRefreshRequest,
    callback: (error: ServiceError | null, response: AdminRefreshResponse) => void,
  ): ClientUnaryCall;
  adminRefresh(
    request: AdminRefreshRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AdminRefreshResponse) => void,
  ): ClientUnaryCall;
  adminRefresh(
    request: AdminRefreshRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AdminRefreshResponse) => void,
  ): ClientUnaryCall;
}

export const AuthServiceClient = makeGenericClientConstructor(
  AuthServiceService,
  "auth_service.AuthService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthServiceClient;
  service: typeof AuthServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
