// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.20.3
// source: user_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';
import { Timestamp } from './google/protobuf/timestamp';

export const protobufPackage = 'user_service';

/** Common User Information */
export interface UserInfo {
  userId: string;
  username: string;
  email: string;
  avatar: string;
  status: string;
  role: string;
  updatedAt: Date | undefined;
  createdAt: Date | undefined;
}

/** Common Pagination Request */
export interface PaginationRequest {
  page: number;
  pageSize: number;
}

/** Common Pagination Response */
export interface PaginationResponse {
  totalItems: number;
  totalPages: number;
}

/** Generic Error Message */
export interface Error {
  /** e.g., "RESOURCE_NOT_FOUND", "INVALID_ARGUMENT", "UNAUTHENTICATED" */
  code: string;
  message: string;
  /** Optional detailed error information */
  details: ErrorDetail[];
}

export interface ErrorDetail {
  field?: string | undefined;
  message: string;
}

export interface WalletTransaction {
  transactionId: string;
  userId: string;
  amount: number;
  /** e.g., "deposit", "withdrawal", "purchase" */
  type: string;
  transactionDate: Date | undefined;
}

/** Register User */
export interface RegisterUserRequest {
  username: string;
  email: string;
  password: string;
  role: string;
  avatar: string;
  /** e.g., "password", "google", "facebook" */
  authType: string;
}

export interface Auth2SignRequest {
  username: string;
  email: string;
  role: string;
  avatar: string;
  /** e.g., "password", "google", "facebook" */
  authType: string;
}

export interface Auth2SignResponse {
  success?: AuthUserResponse | undefined;
  error?: Error | undefined;
}

export interface LogoutUserRequest {
  userId: string;
}

export interface LogoutResponse {
  userId: string;
  message: string;
}

export interface LogoutUserResponse {
  success?: LogoutResponse | undefined;
  error?: Error | undefined;
}

/** Verify User */
export interface VerifyUserRequest {
  email: string;
}

export interface RegisterUserResponse {
  userId?: string | undefined;
  error?: Error | undefined;
}

/** Login User */
export interface LoginUserRequest {
  email: string;
  password: string;
}

export interface LoginUserResponse {
  success?: AuthUserResponse | undefined;
  error?: Error | undefined;
}

export interface VerifyUserResponse {
  success?: AuthUserResponse | undefined;
  error?: Error | undefined;
}

export interface AuthUserResponse {
  accessToken: string;
  refreshToken: string;
  user: UserInfo | undefined;
}

export interface InstructorSuccessResponse {
  accessToken: string;
  refreshToken: string;
  user: UserInfo | undefined;
}

export interface RegisterInstructorResponse {
  error?: Error | undefined;
  success?: InstructorSuccessResponse | undefined;
}

/** Get New Refresh Token */
export interface GetRefreshTokenRequest {
  refreshToken: string;
}

export interface RegisterInstructorRequest {
  userId: string;
}

export interface GetRefreshTokenResponse {
  success?: RefreshSuccess | undefined;
  error?: Error | undefined;
}

export interface RefreshSuccess {
  accessToken: string;
  refreshToken: string;
}

/** Forgot Password */
export interface ForgotPasswordRequest {
  email: string;
}

export interface ForgotPasswordResponse {
  success?: ForgotPasswordSuccess | undefined;
  error?: Error | undefined;
}

export interface ForgotPasswordSuccess {
  acknowledged: boolean;
}

export interface GetDetailedUserRequest {
  userId: string;
}

export interface GetDetailedUserResponse {
  user?: DetailedUserInfo | undefined;
  error?: Error | undefined;
}

export interface DetailedUserInfo {
  userId: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  headline?: string | undefined;
  biography?: string | undefined;
  avatar?: string | undefined;
  website?: string | undefined;
  language?: string | undefined;
  facebook?: string | undefined;
  instagram?: string | undefined;
  linkedin?: string | undefined;
  status: string;
  role: string;
  email: string;
  updatedAt: Date | undefined;
  createdAt: Date | undefined;
}

/** Update User Details */
export interface UpdateUserDetailsRequest {
  userId: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  headline?: string | undefined;
  biography?: string | undefined;
  avatar?: string | undefined;
  website?: string | undefined;
  language?: string | undefined;
  facebook?: string | undefined;
  instagram?: string | undefined;
  linkedin?: string | undefined;
}

export interface UpdateUserDetailsResponse {
  user?: UserInfo | undefined;
  error?: Error | undefined;
}

/** Change Password */
export interface ChangePasswordRequest {
  userId: string;
  oldPassword: string;
  newPassword: string;
}

export interface ChangePasswordResponse {
  success?: ChangePasswordSuccess | undefined;
  error?: Error | undefined;
}

export interface ChangePasswordSuccess {
  updated: boolean;
}

/** Get Wallet Transactions */
export interface GetWalletTransactionsRequest {
  userId: string;
  pagination: PaginationRequest | undefined;
}

export interface GetWalletTransactionsResponse {
  success?: WalletTransactionsSuccess | undefined;
  error?: Error | undefined;
}

export interface WalletTransactionsSuccess {
  transactions: WalletTransaction[];
  pagination: PaginationResponse | undefined;
}

/** Get All Users */
export interface GetAllUsersRequest {
  pagination: PaginationRequest | undefined;
}

export interface GetAllUserEmailsRequest {}

export interface GetAllUsersResponse {
  success?: AllUsersSuccess | undefined;
  error?: Error | undefined;
}

export interface GetAllUserEmailsResponse {
  success?: AllUserEmailsSuccess | undefined;
  error?: Error | undefined;
}

export interface AllUserEmailsSuccess {
  email: string[];
}

export interface AllUsersSuccess {
  users: UserInfo[];
  pagination: PaginationResponse | undefined;
}

/** Get User By ID */
export interface GetUserByIdRequest {
  userId: string;
}

export interface GetCurrentUserRequest {
  userId: string;
}

export interface CheckUserByEmailRequest {
  email: string;
}

export interface EmailExist {
  success: string;
  error: string;
}

export interface CheckUserByEmailResponse {
  response?: EmailExist | undefined;
  error?: Error | undefined;
}

export interface GetCurrentUserResponse {
  user?: UserInfo | undefined;
  error?: Error | undefined;
}

export interface GetUserByIdResponse {
  user?: UserInfo | undefined;
  error?: Error | undefined;
}

/** Block User */
export interface BlockUserRequest {
  userId: string;
}

export interface UnBlockUserRequest {
  userId: string;
}

export interface BlockUserResponse {
  success?: BlockUserSuccess | undefined;
  error?: Error | undefined;
}

export interface UnBlockUserResponse {
  success?: UnBlockUserSuccess | undefined;
  error?: Error | undefined;
}

export interface BlockUserSuccess {
  updated: boolean;
}

export interface UnBlockUserSuccess {
  updated: boolean;
}

/** Get All Instructors */
export interface GetAllInstructorsRequest {
  pagination: PaginationRequest | undefined;
}

export interface GetAllInstructorsResponse {
  success?: AllInstructorsSuccess | undefined;
  error?: Error | undefined;
}

export interface AllInstructorsSuccess {
  instructors: UserInfo[];
  pagination: PaginationResponse | undefined;
}

function createBaseUserInfo(): UserInfo {
  return {
    userId: '',
    username: '',
    email: '',
    avatar: '',
    status: '',
    role: '',
    updatedAt: undefined,
    createdAt: undefined,
  };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== '') {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== '') {
      writer.uint32(26).string(message.email);
    }
    if (message.avatar !== '') {
      writer.uint32(34).string(message.avatar);
    }
    if (message.status !== '') {
      writer.uint32(42).string(message.status);
    }
    if (message.role !== '') {
      writer.uint32(50).string(message.role);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      username: isSet(object.username) ? globalThis.String(object.username) : '',
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : '',
      status: isSet(object.status) ? globalThis.String(object.status) : '',
      role: isSet(object.role) ? globalThis.String(object.role) : '',
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.username !== '') {
      obj.username = message.username;
    }
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.avatar !== '') {
      obj.avatar = message.avatar;
    }
    if (message.status !== '') {
      obj.status = message.status;
    }
    if (message.role !== '') {
      obj.role = message.role;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.userId = object.userId ?? '';
    message.username = object.username ?? '';
    message.email = object.email ?? '';
    message.avatar = object.avatar ?? '';
    message.status = object.status ?? '';
    message.role = object.role ?? '';
    message.updatedAt = object.updatedAt ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { page: 0, pageSize: 0 };
}

export const PaginationRequest: MessageFns<PaginationRequest> = {
  encode(message: PaginationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: PaginationRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationRequest>, I>>(base?: I): PaginationRequest {
    return PaginationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationRequest>, I>>(object: I): PaginationRequest {
    const message = createBasePaginationRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { totalItems: 0, totalPages: 0 };
}

export const PaginationResponse: MessageFns<PaginationResponse> = {
  encode(message: PaginationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalItems !== 0) {
      writer.uint32(8).int32(message.totalItems);
    }
    if (message.totalPages !== 0) {
      writer.uint32(16).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResponse {
    return {
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: PaginationResponse): unknown {
    const obj: any = {};
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResponse>, I>>(base?: I): PaginationResponse {
    return PaginationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResponse>, I>>(object: I): PaginationResponse {
    const message = createBasePaginationResponse();
    message.totalItems = object.totalItems ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseError(): Error {
  return { code: '', message: '', details: [] };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== '') {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.details) {
      ErrorDetail.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
      details: globalThis.Array.isArray(object?.details)
        ? object.details.map((e: any) => ErrorDetail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== '') {
      obj.code = message.code;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => ErrorDetail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? '';
    message.message = object.message ?? '';
    message.details = object.details?.map((e) => ErrorDetail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseErrorDetail(): ErrorDetail {
  return { field: undefined, message: '' };
}

export const ErrorDetail: MessageFns<ErrorDetail> = {
  encode(message: ErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined) {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorDetail {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: ErrorDetail): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = message.field;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorDetail>, I>>(base?: I): ErrorDetail {
    return ErrorDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorDetail>, I>>(object: I): ErrorDetail {
    const message = createBaseErrorDetail();
    message.field = object.field ?? undefined;
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseWalletTransaction(): WalletTransaction {
  return { transactionId: '', userId: '', amount: 0, type: '', transactionDate: undefined };
}

export const WalletTransaction: MessageFns<WalletTransaction> = {
  encode(message: WalletTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== '') {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.amount !== 0) {
      writer.uint32(25).double(message.amount);
    }
    if (message.type !== '') {
      writer.uint32(34).string(message.type);
    }
    if (message.transactionDate !== undefined) {
      Timestamp.encode(toTimestamp(message.transactionDate), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transactionDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletTransaction {
    return {
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : '',
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : '',
      transactionDate: isSet(object.transactionDate)
        ? fromJsonTimestamp(object.transactionDate)
        : undefined,
    };
  },

  toJSON(message: WalletTransaction): unknown {
    const obj: any = {};
    if (message.transactionId !== '') {
      obj.transactionId = message.transactionId;
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.type !== '') {
      obj.type = message.type;
    }
    if (message.transactionDate !== undefined) {
      obj.transactionDate = message.transactionDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletTransaction>, I>>(base?: I): WalletTransaction {
    return WalletTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletTransaction>, I>>(object: I): WalletTransaction {
    const message = createBaseWalletTransaction();
    message.transactionId = object.transactionId ?? '';
    message.userId = object.userId ?? '';
    message.amount = object.amount ?? 0;
    message.type = object.type ?? '';
    message.transactionDate = object.transactionDate ?? undefined;
    return message;
  },
};

function createBaseRegisterUserRequest(): RegisterUserRequest {
  return { username: '', email: '', password: '', role: '', avatar: '', authType: '' };
}

export const RegisterUserRequest: MessageFns<RegisterUserRequest> = {
  encode(message: RegisterUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== '') {
      writer.uint32(10).string(message.username);
    }
    if (message.email !== '') {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== '') {
      writer.uint32(26).string(message.password);
    }
    if (message.role !== '') {
      writer.uint32(34).string(message.role);
    }
    if (message.avatar !== '') {
      writer.uint32(42).string(message.avatar);
    }
    if (message.authType !== '') {
      writer.uint32(50).string(message.authType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.authType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : '',
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      password: isSet(object.password) ? globalThis.String(object.password) : '',
      role: isSet(object.role) ? globalThis.String(object.role) : '',
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : '',
      authType: isSet(object.authType) ? globalThis.String(object.authType) : '',
    };
  },

  toJSON(message: RegisterUserRequest): unknown {
    const obj: any = {};
    if (message.username !== '') {
      obj.username = message.username;
    }
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.password !== '') {
      obj.password = message.password;
    }
    if (message.role !== '') {
      obj.role = message.role;
    }
    if (message.avatar !== '') {
      obj.avatar = message.avatar;
    }
    if (message.authType !== '') {
      obj.authType = message.authType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(base?: I): RegisterUserRequest {
    return RegisterUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(
    object: I,
  ): RegisterUserRequest {
    const message = createBaseRegisterUserRequest();
    message.username = object.username ?? '';
    message.email = object.email ?? '';
    message.password = object.password ?? '';
    message.role = object.role ?? '';
    message.avatar = object.avatar ?? '';
    message.authType = object.authType ?? '';
    return message;
  },
};

function createBaseAuth2SignRequest(): Auth2SignRequest {
  return { username: '', email: '', role: '', avatar: '', authType: '' };
}

export const Auth2SignRequest: MessageFns<Auth2SignRequest> = {
  encode(message: Auth2SignRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== '') {
      writer.uint32(10).string(message.username);
    }
    if (message.email !== '') {
      writer.uint32(18).string(message.email);
    }
    if (message.role !== '') {
      writer.uint32(34).string(message.role);
    }
    if (message.avatar !== '') {
      writer.uint32(42).string(message.avatar);
    }
    if (message.authType !== '') {
      writer.uint32(50).string(message.authType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Auth2SignRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuth2SignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.authType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Auth2SignRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : '',
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      role: isSet(object.role) ? globalThis.String(object.role) : '',
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : '',
      authType: isSet(object.authType) ? globalThis.String(object.authType) : '',
    };
  },

  toJSON(message: Auth2SignRequest): unknown {
    const obj: any = {};
    if (message.username !== '') {
      obj.username = message.username;
    }
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.role !== '') {
      obj.role = message.role;
    }
    if (message.avatar !== '') {
      obj.avatar = message.avatar;
    }
    if (message.authType !== '') {
      obj.authType = message.authType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Auth2SignRequest>, I>>(base?: I): Auth2SignRequest {
    return Auth2SignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Auth2SignRequest>, I>>(object: I): Auth2SignRequest {
    const message = createBaseAuth2SignRequest();
    message.username = object.username ?? '';
    message.email = object.email ?? '';
    message.role = object.role ?? '';
    message.avatar = object.avatar ?? '';
    message.authType = object.authType ?? '';
    return message;
  },
};

function createBaseAuth2SignResponse(): Auth2SignResponse {
  return { success: undefined, error: undefined };
}

export const Auth2SignResponse: MessageFns<Auth2SignResponse> = {
  encode(message: Auth2SignResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AuthUserResponse.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Auth2SignResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuth2SignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AuthUserResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Auth2SignResponse {
    return {
      success: isSet(object.success) ? AuthUserResponse.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: Auth2SignResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AuthUserResponse.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Auth2SignResponse>, I>>(base?: I): Auth2SignResponse {
    return Auth2SignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Auth2SignResponse>, I>>(object: I): Auth2SignResponse {
    const message = createBaseAuth2SignResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? AuthUserResponse.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseLogoutUserRequest(): LogoutUserRequest {
  return { userId: '' };
}

export const LogoutUserRequest: MessageFns<LogoutUserRequest> = {
  encode(message: LogoutUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : '' };
  },

  toJSON(message: LogoutUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutUserRequest>, I>>(base?: I): LogoutUserRequest {
    return LogoutUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutUserRequest>, I>>(object: I): LogoutUserRequest {
    const message = createBaseLogoutUserRequest();
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseLogoutResponse(): LogoutResponse {
  return { userId: '', message: '' };
}

export const LogoutResponse: MessageFns<LogoutResponse> = {
  encode(message: LogoutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: LogoutResponse): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutResponse>, I>>(base?: I): LogoutResponse {
    return LogoutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutResponse>, I>>(object: I): LogoutResponse {
    const message = createBaseLogoutResponse();
    message.userId = object.userId ?? '';
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseLogoutUserResponse(): LogoutUserResponse {
  return { success: undefined, error: undefined };
}

export const LogoutUserResponse: MessageFns<LogoutUserResponse> = {
  encode(message: LogoutUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      LogoutResponse.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = LogoutResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutUserResponse {
    return {
      success: isSet(object.success) ? LogoutResponse.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: LogoutUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = LogoutResponse.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutUserResponse>, I>>(base?: I): LogoutUserResponse {
    return LogoutUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutUserResponse>, I>>(object: I): LogoutUserResponse {
    const message = createBaseLogoutUserResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? LogoutResponse.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseVerifyUserRequest(): VerifyUserRequest {
  return { email: '' };
}

export const VerifyUserRequest: MessageFns<VerifyUserRequest> = {
  encode(message: VerifyUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== '') {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyUserRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : '' };
  },

  toJSON(message: VerifyUserRequest): unknown {
    const obj: any = {};
    if (message.email !== '') {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyUserRequest>, I>>(base?: I): VerifyUserRequest {
    return VerifyUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyUserRequest>, I>>(object: I): VerifyUserRequest {
    const message = createBaseVerifyUserRequest();
    message.email = object.email ?? '';
    return message;
  },
};

function createBaseRegisterUserResponse(): RegisterUserResponse {
  return { userId: undefined, error: undefined };
}

export const RegisterUserResponse: MessageFns<RegisterUserResponse> = {
  encode(message: RegisterUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== undefined) {
      writer.uint32(10).string(message.userId);
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: RegisterUserResponse): unknown {
    const obj: any = {};
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(base?: I): RegisterUserResponse {
    return RegisterUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(
    object: I,
  ): RegisterUserResponse {
    const message = createBaseRegisterUserResponse();
    message.userId = object.userId ?? undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseLoginUserRequest(): LoginUserRequest {
  return { email: '', password: '' };
}

export const LoginUserRequest: MessageFns<LoginUserRequest> = {
  encode(message: LoginUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== '') {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== '') {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginUserRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      password: isSet(object.password) ? globalThis.String(object.password) : '',
    };
  },

  toJSON(message: LoginUserRequest): unknown {
    const obj: any = {};
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.password !== '') {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginUserRequest>, I>>(base?: I): LoginUserRequest {
    return LoginUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginUserRequest>, I>>(object: I): LoginUserRequest {
    const message = createBaseLoginUserRequest();
    message.email = object.email ?? '';
    message.password = object.password ?? '';
    return message;
  },
};

function createBaseLoginUserResponse(): LoginUserResponse {
  return { success: undefined, error: undefined };
}

export const LoginUserResponse: MessageFns<LoginUserResponse> = {
  encode(message: LoginUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AuthUserResponse.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AuthUserResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginUserResponse {
    return {
      success: isSet(object.success) ? AuthUserResponse.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: LoginUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AuthUserResponse.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginUserResponse>, I>>(base?: I): LoginUserResponse {
    return LoginUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginUserResponse>, I>>(object: I): LoginUserResponse {
    const message = createBaseLoginUserResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? AuthUserResponse.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseVerifyUserResponse(): VerifyUserResponse {
  return { success: undefined, error: undefined };
}

export const VerifyUserResponse: MessageFns<VerifyUserResponse> = {
  encode(message: VerifyUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AuthUserResponse.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AuthUserResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyUserResponse {
    return {
      success: isSet(object.success) ? AuthUserResponse.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: VerifyUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AuthUserResponse.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyUserResponse>, I>>(base?: I): VerifyUserResponse {
    return VerifyUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyUserResponse>, I>>(object: I): VerifyUserResponse {
    const message = createBaseVerifyUserResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? AuthUserResponse.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseAuthUserResponse(): AuthUserResponse {
  return { accessToken: '', refreshToken: '', user: undefined };
}

export const AuthUserResponse: MessageFns<AuthUserResponse> = {
  encode(message: AuthUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== '') {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== '') {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthUserResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : '',
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : '',
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: AuthUserResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== '') {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== '') {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthUserResponse>, I>>(base?: I): AuthUserResponse {
    return AuthUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthUserResponse>, I>>(object: I): AuthUserResponse {
    const message = createBaseAuthUserResponse();
    message.accessToken = object.accessToken ?? '';
    message.refreshToken = object.refreshToken ?? '';
    message.user =
      object.user !== undefined && object.user !== null
        ? UserInfo.fromPartial(object.user)
        : undefined;
    return message;
  },
};

function createBaseInstructorSuccessResponse(): InstructorSuccessResponse {
  return { accessToken: '', refreshToken: '', user: undefined };
}

export const InstructorSuccessResponse: MessageFns<InstructorSuccessResponse> = {
  encode(
    message: InstructorSuccessResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accessToken !== '') {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== '') {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstructorSuccessResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstructorSuccessResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstructorSuccessResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : '',
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : '',
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: InstructorSuccessResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== '') {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== '') {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstructorSuccessResponse>, I>>(
    base?: I,
  ): InstructorSuccessResponse {
    return InstructorSuccessResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstructorSuccessResponse>, I>>(
    object: I,
  ): InstructorSuccessResponse {
    const message = createBaseInstructorSuccessResponse();
    message.accessToken = object.accessToken ?? '';
    message.refreshToken = object.refreshToken ?? '';
    message.user =
      object.user !== undefined && object.user !== null
        ? UserInfo.fromPartial(object.user)
        : undefined;
    return message;
  },
};

function createBaseRegisterInstructorResponse(): RegisterInstructorResponse {
  return { error: undefined, success: undefined };
}

export const RegisterInstructorResponse: MessageFns<RegisterInstructorResponse> = {
  encode(
    message: RegisterInstructorResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(10).fork()).join();
    }
    if (message.success !== undefined) {
      InstructorSuccessResponse.encode(message.success, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterInstructorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterInstructorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.success = InstructorSuccessResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterInstructorResponse {
    return {
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      success: isSet(object.success)
        ? InstructorSuccessResponse.fromJSON(object.success)
        : undefined,
    };
  },

  toJSON(message: RegisterInstructorResponse): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.success !== undefined) {
      obj.success = InstructorSuccessResponse.toJSON(message.success);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterInstructorResponse>, I>>(
    base?: I,
  ): RegisterInstructorResponse {
    return RegisterInstructorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterInstructorResponse>, I>>(
    object: I,
  ): RegisterInstructorResponse {
    const message = createBaseRegisterInstructorResponse();
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    message.success =
      object.success !== undefined && object.success !== null
        ? InstructorSuccessResponse.fromPartial(object.success)
        : undefined;
    return message;
  },
};

function createBaseGetRefreshTokenRequest(): GetRefreshTokenRequest {
  return { refreshToken: '' };
}

export const GetRefreshTokenRequest: MessageFns<GetRefreshTokenRequest> = {
  encode(message: GetRefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== '') {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRefreshTokenRequest {
    return {
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : '',
    };
  },

  toJSON(message: GetRefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== '') {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRefreshTokenRequest>, I>>(
    base?: I,
  ): GetRefreshTokenRequest {
    return GetRefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRefreshTokenRequest>, I>>(
    object: I,
  ): GetRefreshTokenRequest {
    const message = createBaseGetRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? '';
    return message;
  },
};

function createBaseRegisterInstructorRequest(): RegisterInstructorRequest {
  return { userId: '' };
}

export const RegisterInstructorRequest: MessageFns<RegisterInstructorRequest> = {
  encode(
    message: RegisterInstructorRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterInstructorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterInstructorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterInstructorRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : '' };
  },

  toJSON(message: RegisterInstructorRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterInstructorRequest>, I>>(
    base?: I,
  ): RegisterInstructorRequest {
    return RegisterInstructorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterInstructorRequest>, I>>(
    object: I,
  ): RegisterInstructorRequest {
    const message = createBaseRegisterInstructorRequest();
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseGetRefreshTokenResponse(): GetRefreshTokenResponse {
  return { success: undefined, error: undefined };
}

export const GetRefreshTokenResponse: MessageFns<GetRefreshTokenResponse> = {
  encode(
    message: GetRefreshTokenResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== undefined) {
      RefreshSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRefreshTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = RefreshSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRefreshTokenResponse {
    return {
      success: isSet(object.success) ? RefreshSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetRefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = RefreshSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRefreshTokenResponse>, I>>(
    base?: I,
  ): GetRefreshTokenResponse {
    return GetRefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRefreshTokenResponse>, I>>(
    object: I,
  ): GetRefreshTokenResponse {
    const message = createBaseGetRefreshTokenResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? RefreshSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseRefreshSuccess(): RefreshSuccess {
  return { accessToken: '', refreshToken: '' };
}

export const RefreshSuccess: MessageFns<RefreshSuccess> = {
  encode(message: RefreshSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== '') {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== '') {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshSuccess {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : '',
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : '',
    };
  },

  toJSON(message: RefreshSuccess): unknown {
    const obj: any = {};
    if (message.accessToken !== '') {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== '') {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshSuccess>, I>>(base?: I): RefreshSuccess {
    return RefreshSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshSuccess>, I>>(object: I): RefreshSuccess {
    const message = createBaseRefreshSuccess();
    message.accessToken = object.accessToken ?? '';
    message.refreshToken = object.refreshToken ?? '';
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { email: '' };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(message: ForgotPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== '') {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : '' };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== '') {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(base?: I): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(
    object: I,
  ): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.email = object.email ?? '';
    return message;
  },
};

function createBaseForgotPasswordResponse(): ForgotPasswordResponse {
  return { success: undefined, error: undefined };
}

export const ForgotPasswordResponse: MessageFns<ForgotPasswordResponse> = {
  encode(message: ForgotPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      ForgotPasswordSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = ForgotPasswordSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordResponse {
    return {
      success: isSet(object.success) ? ForgotPasswordSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ForgotPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = ForgotPasswordSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(
    base?: I,
  ): ForgotPasswordResponse {
    return ForgotPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(
    object: I,
  ): ForgotPasswordResponse {
    const message = createBaseForgotPasswordResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? ForgotPasswordSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseForgotPasswordSuccess(): ForgotPasswordSuccess {
  return { acknowledged: false };
}

export const ForgotPasswordSuccess: MessageFns<ForgotPasswordSuccess> = {
  encode(message: ForgotPasswordSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.acknowledged !== false) {
      writer.uint32(8).bool(message.acknowledged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.acknowledged = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordSuccess {
    return {
      acknowledged: isSet(object.acknowledged) ? globalThis.Boolean(object.acknowledged) : false,
    };
  },

  toJSON(message: ForgotPasswordSuccess): unknown {
    const obj: any = {};
    if (message.acknowledged !== false) {
      obj.acknowledged = message.acknowledged;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordSuccess>, I>>(base?: I): ForgotPasswordSuccess {
    return ForgotPasswordSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordSuccess>, I>>(
    object: I,
  ): ForgotPasswordSuccess {
    const message = createBaseForgotPasswordSuccess();
    message.acknowledged = object.acknowledged ?? false;
    return message;
  },
};

function createBaseGetDetailedUserRequest(): GetDetailedUserRequest {
  return { userId: '' };
}

export const GetDetailedUserRequest: MessageFns<GetDetailedUserRequest> = {
  encode(message: GetDetailedUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDetailedUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDetailedUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDetailedUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : '' };
  },

  toJSON(message: GetDetailedUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDetailedUserRequest>, I>>(
    base?: I,
  ): GetDetailedUserRequest {
    return GetDetailedUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDetailedUserRequest>, I>>(
    object: I,
  ): GetDetailedUserRequest {
    const message = createBaseGetDetailedUserRequest();
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseGetDetailedUserResponse(): GetDetailedUserResponse {
  return { user: undefined, error: undefined };
}

export const GetDetailedUserResponse: MessageFns<GetDetailedUserResponse> = {
  encode(
    message: GetDetailedUserResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      DetailedUserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDetailedUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDetailedUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = DetailedUserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDetailedUserResponse {
    return {
      user: isSet(object.user) ? DetailedUserInfo.fromJSON(object.user) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetDetailedUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = DetailedUserInfo.toJSON(message.user);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDetailedUserResponse>, I>>(
    base?: I,
  ): GetDetailedUserResponse {
    return GetDetailedUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDetailedUserResponse>, I>>(
    object: I,
  ): GetDetailedUserResponse {
    const message = createBaseGetDetailedUserResponse();
    message.user =
      object.user !== undefined && object.user !== null
        ? DetailedUserInfo.fromPartial(object.user)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseDetailedUserInfo(): DetailedUserInfo {
  return {
    userId: '',
    firstName: undefined,
    lastName: undefined,
    phone: undefined,
    headline: undefined,
    biography: undefined,
    avatar: undefined,
    website: undefined,
    language: undefined,
    facebook: undefined,
    instagram: undefined,
    linkedin: undefined,
    status: '',
    role: '',
    email: '',
    updatedAt: undefined,
    createdAt: undefined,
  };
}

export const DetailedUserInfo: MessageFns<DetailedUserInfo> = {
  encode(message: DetailedUserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.firstName !== undefined) {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(26).string(message.lastName);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.headline !== undefined) {
      writer.uint32(42).string(message.headline);
    }
    if (message.biography !== undefined) {
      writer.uint32(50).string(message.biography);
    }
    if (message.avatar !== undefined) {
      writer.uint32(58).string(message.avatar);
    }
    if (message.website !== undefined) {
      writer.uint32(66).string(message.website);
    }
    if (message.language !== undefined) {
      writer.uint32(74).string(message.language);
    }
    if (message.facebook !== undefined) {
      writer.uint32(82).string(message.facebook);
    }
    if (message.instagram !== undefined) {
      writer.uint32(90).string(message.instagram);
    }
    if (message.linkedin !== undefined) {
      writer.uint32(98).string(message.linkedin);
    }
    if (message.status !== '') {
      writer.uint32(106).string(message.status);
    }
    if (message.role !== '') {
      writer.uint32(114).string(message.role);
    }
    if (message.email !== '') {
      writer.uint32(122).string(message.email);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(130).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailedUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailedUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.headline = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.biography = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.facebook = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.instagram = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.linkedin = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailedUserInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      headline: isSet(object.headline) ? globalThis.String(object.headline) : undefined,
      biography: isSet(object.biography) ? globalThis.String(object.biography) : undefined,
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : undefined,
      website: isSet(object.website) ? globalThis.String(object.website) : undefined,
      language: isSet(object.language) ? globalThis.String(object.language) : undefined,
      facebook: isSet(object.facebook) ? globalThis.String(object.facebook) : undefined,
      instagram: isSet(object.instagram) ? globalThis.String(object.instagram) : undefined,
      linkedin: isSet(object.linkedin) ? globalThis.String(object.linkedin) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : '',
      role: isSet(object.role) ? globalThis.String(object.role) : '',
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: DetailedUserInfo): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.headline !== undefined) {
      obj.headline = message.headline;
    }
    if (message.biography !== undefined) {
      obj.biography = message.biography;
    }
    if (message.avatar !== undefined) {
      obj.avatar = message.avatar;
    }
    if (message.website !== undefined) {
      obj.website = message.website;
    }
    if (message.language !== undefined) {
      obj.language = message.language;
    }
    if (message.facebook !== undefined) {
      obj.facebook = message.facebook;
    }
    if (message.instagram !== undefined) {
      obj.instagram = message.instagram;
    }
    if (message.linkedin !== undefined) {
      obj.linkedin = message.linkedin;
    }
    if (message.status !== '') {
      obj.status = message.status;
    }
    if (message.role !== '') {
      obj.role = message.role;
    }
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailedUserInfo>, I>>(base?: I): DetailedUserInfo {
    return DetailedUserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailedUserInfo>, I>>(object: I): DetailedUserInfo {
    const message = createBaseDetailedUserInfo();
    message.userId = object.userId ?? '';
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    message.phone = object.phone ?? undefined;
    message.headline = object.headline ?? undefined;
    message.biography = object.biography ?? undefined;
    message.avatar = object.avatar ?? undefined;
    message.website = object.website ?? undefined;
    message.language = object.language ?? undefined;
    message.facebook = object.facebook ?? undefined;
    message.instagram = object.instagram ?? undefined;
    message.linkedin = object.linkedin ?? undefined;
    message.status = object.status ?? '';
    message.role = object.role ?? '';
    message.email = object.email ?? '';
    message.updatedAt = object.updatedAt ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseUpdateUserDetailsRequest(): UpdateUserDetailsRequest {
  return {
    userId: '',
    firstName: undefined,
    lastName: undefined,
    phone: undefined,
    headline: undefined,
    biography: undefined,
    avatar: undefined,
    website: undefined,
    language: undefined,
    facebook: undefined,
    instagram: undefined,
    linkedin: undefined,
  };
}

export const UpdateUserDetailsRequest: MessageFns<UpdateUserDetailsRequest> = {
  encode(
    message: UpdateUserDetailsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.firstName !== undefined) {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(26).string(message.lastName);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.headline !== undefined) {
      writer.uint32(42).string(message.headline);
    }
    if (message.biography !== undefined) {
      writer.uint32(50).string(message.biography);
    }
    if (message.avatar !== undefined) {
      writer.uint32(58).string(message.avatar);
    }
    if (message.website !== undefined) {
      writer.uint32(66).string(message.website);
    }
    if (message.language !== undefined) {
      writer.uint32(74).string(message.language);
    }
    if (message.facebook !== undefined) {
      writer.uint32(82).string(message.facebook);
    }
    if (message.instagram !== undefined) {
      writer.uint32(90).string(message.instagram);
    }
    if (message.linkedin !== undefined) {
      writer.uint32(98).string(message.linkedin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.headline = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.biography = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.facebook = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.instagram = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.linkedin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserDetailsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      headline: isSet(object.headline) ? globalThis.String(object.headline) : undefined,
      biography: isSet(object.biography) ? globalThis.String(object.biography) : undefined,
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : undefined,
      website: isSet(object.website) ? globalThis.String(object.website) : undefined,
      language: isSet(object.language) ? globalThis.String(object.language) : undefined,
      facebook: isSet(object.facebook) ? globalThis.String(object.facebook) : undefined,
      instagram: isSet(object.instagram) ? globalThis.String(object.instagram) : undefined,
      linkedin: isSet(object.linkedin) ? globalThis.String(object.linkedin) : undefined,
    };
  },

  toJSON(message: UpdateUserDetailsRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.headline !== undefined) {
      obj.headline = message.headline;
    }
    if (message.biography !== undefined) {
      obj.biography = message.biography;
    }
    if (message.avatar !== undefined) {
      obj.avatar = message.avatar;
    }
    if (message.website !== undefined) {
      obj.website = message.website;
    }
    if (message.language !== undefined) {
      obj.language = message.language;
    }
    if (message.facebook !== undefined) {
      obj.facebook = message.facebook;
    }
    if (message.instagram !== undefined) {
      obj.instagram = message.instagram;
    }
    if (message.linkedin !== undefined) {
      obj.linkedin = message.linkedin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserDetailsRequest>, I>>(
    base?: I,
  ): UpdateUserDetailsRequest {
    return UpdateUserDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserDetailsRequest>, I>>(
    object: I,
  ): UpdateUserDetailsRequest {
    const message = createBaseUpdateUserDetailsRequest();
    message.userId = object.userId ?? '';
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    message.phone = object.phone ?? undefined;
    message.headline = object.headline ?? undefined;
    message.biography = object.biography ?? undefined;
    message.avatar = object.avatar ?? undefined;
    message.website = object.website ?? undefined;
    message.language = object.language ?? undefined;
    message.facebook = object.facebook ?? undefined;
    message.instagram = object.instagram ?? undefined;
    message.linkedin = object.linkedin ?? undefined;
    return message;
  },
};

function createBaseUpdateUserDetailsResponse(): UpdateUserDetailsResponse {
  return { user: undefined, error: undefined };
}

export const UpdateUserDetailsResponse: MessageFns<UpdateUserDetailsResponse> = {
  encode(
    message: UpdateUserDetailsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserDetailsResponse {
    return {
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: UpdateUserDetailsResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserDetailsResponse>, I>>(
    base?: I,
  ): UpdateUserDetailsResponse {
    return UpdateUserDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserDetailsResponse>, I>>(
    object: I,
  ): UpdateUserDetailsResponse {
    const message = createBaseUpdateUserDetailsResponse();
    message.user =
      object.user !== undefined && object.user !== null
        ? UserInfo.fromPartial(object.user)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseChangePasswordRequest(): ChangePasswordRequest {
  return { userId: '', oldPassword: '', newPassword: '' };
}

export const ChangePasswordRequest: MessageFns<ChangePasswordRequest> = {
  encode(message: ChangePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.oldPassword !== '') {
      writer.uint32(18).string(message.oldPassword);
    }
    if (message.newPassword !== '') {
      writer.uint32(26).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      oldPassword: isSet(object.oldPassword) ? globalThis.String(object.oldPassword) : '',
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : '',
    };
  },

  toJSON(message: ChangePasswordRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.oldPassword !== '') {
      obj.oldPassword = message.oldPassword;
    }
    if (message.newPassword !== '') {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(base?: I): ChangePasswordRequest {
    return ChangePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(
    object: I,
  ): ChangePasswordRequest {
    const message = createBaseChangePasswordRequest();
    message.userId = object.userId ?? '';
    message.oldPassword = object.oldPassword ?? '';
    message.newPassword = object.newPassword ?? '';
    return message;
  },
};

function createBaseChangePasswordResponse(): ChangePasswordResponse {
  return { success: undefined, error: undefined };
}

export const ChangePasswordResponse: MessageFns<ChangePasswordResponse> = {
  encode(message: ChangePasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      ChangePasswordSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = ChangePasswordSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordResponse {
    return {
      success: isSet(object.success) ? ChangePasswordSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ChangePasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = ChangePasswordSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordResponse>, I>>(
    base?: I,
  ): ChangePasswordResponse {
    return ChangePasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordResponse>, I>>(
    object: I,
  ): ChangePasswordResponse {
    const message = createBaseChangePasswordResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? ChangePasswordSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseChangePasswordSuccess(): ChangePasswordSuccess {
  return { updated: false };
}

export const ChangePasswordSuccess: MessageFns<ChangePasswordSuccess> = {
  encode(message: ChangePasswordSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: ChangePasswordSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordSuccess>, I>>(base?: I): ChangePasswordSuccess {
    return ChangePasswordSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordSuccess>, I>>(
    object: I,
  ): ChangePasswordSuccess {
    const message = createBaseChangePasswordSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

function createBaseGetWalletTransactionsRequest(): GetWalletTransactionsRequest {
  return { userId: '', pagination: undefined };
}

export const GetWalletTransactionsRequest: MessageFns<GetWalletTransactionsRequest> = {
  encode(
    message: GetWalletTransactionsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWalletTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletTransactionsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      pagination: isSet(object.pagination)
        ? PaginationRequest.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: GetWalletTransactionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWalletTransactionsRequest>, I>>(
    base?: I,
  ): GetWalletTransactionsRequest {
    return GetWalletTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWalletTransactionsRequest>, I>>(
    object: I,
  ): GetWalletTransactionsRequest {
    const message = createBaseGetWalletTransactionsRequest();
    message.userId = object.userId ?? '';
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PaginationRequest.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseGetWalletTransactionsResponse(): GetWalletTransactionsResponse {
  return { success: undefined, error: undefined };
}

export const GetWalletTransactionsResponse: MessageFns<GetWalletTransactionsResponse> = {
  encode(
    message: GetWalletTransactionsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== undefined) {
      WalletTransactionsSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWalletTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = WalletTransactionsSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletTransactionsResponse {
    return {
      success: isSet(object.success)
        ? WalletTransactionsSuccess.fromJSON(object.success)
        : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetWalletTransactionsResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = WalletTransactionsSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWalletTransactionsResponse>, I>>(
    base?: I,
  ): GetWalletTransactionsResponse {
    return GetWalletTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWalletTransactionsResponse>, I>>(
    object: I,
  ): GetWalletTransactionsResponse {
    const message = createBaseGetWalletTransactionsResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? WalletTransactionsSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseWalletTransactionsSuccess(): WalletTransactionsSuccess {
  return { transactions: [], pagination: undefined };
}

export const WalletTransactionsSuccess: MessageFns<WalletTransactionsSuccess> = {
  encode(
    message: WalletTransactionsSuccess,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.transactions) {
      WalletTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletTransactionsSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletTransactionsSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(WalletTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletTransactionsSuccess {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => WalletTransaction.fromJSON(e))
        : [],
      pagination: isSet(object.pagination)
        ? PaginationResponse.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: WalletTransactionsSuccess): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => WalletTransaction.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletTransactionsSuccess>, I>>(
    base?: I,
  ): WalletTransactionsSuccess {
    return WalletTransactionsSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletTransactionsSuccess>, I>>(
    object: I,
  ): WalletTransactionsSuccess {
    const message = createBaseWalletTransactionsSuccess();
    message.transactions = object.transactions?.map((e) => WalletTransaction.fromPartial(e)) || [];
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PaginationResponse.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseGetAllUsersRequest(): GetAllUsersRequest {
  return { pagination: undefined };
}

export const GetAllUsersRequest: MessageFns<GetAllUsersRequest> = {
  encode(message: GetAllUsersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllUsersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllUsersRequest {
    return {
      pagination: isSet(object.pagination)
        ? PaginationRequest.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: GetAllUsersRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllUsersRequest>, I>>(base?: I): GetAllUsersRequest {
    return GetAllUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllUsersRequest>, I>>(object: I): GetAllUsersRequest {
    const message = createBaseGetAllUsersRequest();
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PaginationRequest.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseGetAllUserEmailsRequest(): GetAllUserEmailsRequest {
  return {};
}

export const GetAllUserEmailsRequest: MessageFns<GetAllUserEmailsRequest> = {
  encode(_: GetAllUserEmailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllUserEmailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUserEmailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAllUserEmailsRequest {
    return {};
  },

  toJSON(_: GetAllUserEmailsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllUserEmailsRequest>, I>>(
    base?: I,
  ): GetAllUserEmailsRequest {
    return GetAllUserEmailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllUserEmailsRequest>, I>>(
    _: I,
  ): GetAllUserEmailsRequest {
    const message = createBaseGetAllUserEmailsRequest();
    return message;
  },
};

function createBaseGetAllUsersResponse(): GetAllUsersResponse {
  return { success: undefined, error: undefined };
}

export const GetAllUsersResponse: MessageFns<GetAllUsersResponse> = {
  encode(message: GetAllUsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AllUsersSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllUsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AllUsersSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllUsersResponse {
    return {
      success: isSet(object.success) ? AllUsersSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetAllUsersResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AllUsersSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllUsersResponse>, I>>(base?: I): GetAllUsersResponse {
    return GetAllUsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllUsersResponse>, I>>(
    object: I,
  ): GetAllUsersResponse {
    const message = createBaseGetAllUsersResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? AllUsersSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseGetAllUserEmailsResponse(): GetAllUserEmailsResponse {
  return { success: undefined, error: undefined };
}

export const GetAllUserEmailsResponse: MessageFns<GetAllUserEmailsResponse> = {
  encode(
    message: GetAllUserEmailsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== undefined) {
      AllUserEmailsSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllUserEmailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUserEmailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AllUserEmailsSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllUserEmailsResponse {
    return {
      success: isSet(object.success) ? AllUserEmailsSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetAllUserEmailsResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AllUserEmailsSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllUserEmailsResponse>, I>>(
    base?: I,
  ): GetAllUserEmailsResponse {
    return GetAllUserEmailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllUserEmailsResponse>, I>>(
    object: I,
  ): GetAllUserEmailsResponse {
    const message = createBaseGetAllUserEmailsResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? AllUserEmailsSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseAllUserEmailsSuccess(): AllUserEmailsSuccess {
  return { email: [] };
}

export const AllUserEmailsSuccess: MessageFns<AllUserEmailsSuccess> = {
  encode(message: AllUserEmailsSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.email) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllUserEmailsSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllUserEmailsSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllUserEmailsSuccess {
    return {
      email: globalThis.Array.isArray(object?.email)
        ? object.email.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AllUserEmailsSuccess): unknown {
    const obj: any = {};
    if (message.email?.length) {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllUserEmailsSuccess>, I>>(base?: I): AllUserEmailsSuccess {
    return AllUserEmailsSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllUserEmailsSuccess>, I>>(
    object: I,
  ): AllUserEmailsSuccess {
    const message = createBaseAllUserEmailsSuccess();
    message.email = object.email?.map((e) => e) || [];
    return message;
  },
};

function createBaseAllUsersSuccess(): AllUsersSuccess {
  return { users: [], pagination: undefined };
}

export const AllUsersSuccess: MessageFns<AllUsersSuccess> = {
  encode(message: AllUsersSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      UserInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllUsersSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllUsersSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(UserInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllUsersSuccess {
    return {
      users: globalThis.Array.isArray(object?.users)
        ? object.users.map((e: any) => UserInfo.fromJSON(e))
        : [],
      pagination: isSet(object.pagination)
        ? PaginationResponse.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: AllUsersSuccess): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => UserInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllUsersSuccess>, I>>(base?: I): AllUsersSuccess {
    return AllUsersSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllUsersSuccess>, I>>(object: I): AllUsersSuccess {
    const message = createBaseAllUsersSuccess();
    message.users = object.users?.map((e) => UserInfo.fromPartial(e)) || [];
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PaginationResponse.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseGetUserByIdRequest(): GetUserByIdRequest {
  return { userId: '' };
}

export const GetUserByIdRequest: MessageFns<GetUserByIdRequest> = {
  encode(message: GetUserByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserByIdRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : '' };
  },

  toJSON(message: GetUserByIdRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserByIdRequest>, I>>(base?: I): GetUserByIdRequest {
    return GetUserByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserByIdRequest>, I>>(object: I): GetUserByIdRequest {
    const message = createBaseGetUserByIdRequest();
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseGetCurrentUserRequest(): GetCurrentUserRequest {
  return { userId: '' };
}

export const GetCurrentUserRequest: MessageFns<GetCurrentUserRequest> = {
  encode(message: GetCurrentUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : '' };
  },

  toJSON(message: GetCurrentUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCurrentUserRequest>, I>>(base?: I): GetCurrentUserRequest {
    return GetCurrentUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCurrentUserRequest>, I>>(
    object: I,
  ): GetCurrentUserRequest {
    const message = createBaseGetCurrentUserRequest();
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseCheckUserByEmailRequest(): CheckUserByEmailRequest {
  return { email: '' };
}

export const CheckUserByEmailRequest: MessageFns<CheckUserByEmailRequest> = {
  encode(
    message: CheckUserByEmailRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.email !== '') {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUserByEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUserByEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUserByEmailRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : '' };
  },

  toJSON(message: CheckUserByEmailRequest): unknown {
    const obj: any = {};
    if (message.email !== '') {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckUserByEmailRequest>, I>>(
    base?: I,
  ): CheckUserByEmailRequest {
    return CheckUserByEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckUserByEmailRequest>, I>>(
    object: I,
  ): CheckUserByEmailRequest {
    const message = createBaseCheckUserByEmailRequest();
    message.email = object.email ?? '';
    return message;
  },
};

function createBaseEmailExist(): EmailExist {
  return { success: '', error: '' };
}

export const EmailExist: MessageFns<EmailExist> = {
  encode(message: EmailExist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== '') {
      writer.uint32(10).string(message.success);
    }
    if (message.error !== '') {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailExist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailExist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailExist {
    return {
      success: isSet(object.success) ? globalThis.String(object.success) : '',
      error: isSet(object.error) ? globalThis.String(object.error) : '',
    };
  },

  toJSON(message: EmailExist): unknown {
    const obj: any = {};
    if (message.success !== '') {
      obj.success = message.success;
    }
    if (message.error !== '') {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailExist>, I>>(base?: I): EmailExist {
    return EmailExist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailExist>, I>>(object: I): EmailExist {
    const message = createBaseEmailExist();
    message.success = object.success ?? '';
    message.error = object.error ?? '';
    return message;
  },
};

function createBaseCheckUserByEmailResponse(): CheckUserByEmailResponse {
  return { response: undefined, error: undefined };
}

export const CheckUserByEmailResponse: MessageFns<CheckUserByEmailResponse> = {
  encode(
    message: CheckUserByEmailResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.response !== undefined) {
      EmailExist.encode(message.response, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUserByEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUserByEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = EmailExist.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUserByEmailResponse {
    return {
      response: isSet(object.response) ? EmailExist.fromJSON(object.response) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: CheckUserByEmailResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = EmailExist.toJSON(message.response);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckUserByEmailResponse>, I>>(
    base?: I,
  ): CheckUserByEmailResponse {
    return CheckUserByEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckUserByEmailResponse>, I>>(
    object: I,
  ): CheckUserByEmailResponse {
    const message = createBaseCheckUserByEmailResponse();
    message.response =
      object.response !== undefined && object.response !== null
        ? EmailExist.fromPartial(object.response)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseGetCurrentUserResponse(): GetCurrentUserResponse {
  return { user: undefined, error: undefined };
}

export const GetCurrentUserResponse: MessageFns<GetCurrentUserResponse> = {
  encode(message: GetCurrentUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentUserResponse {
    return {
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetCurrentUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCurrentUserResponse>, I>>(
    base?: I,
  ): GetCurrentUserResponse {
    return GetCurrentUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCurrentUserResponse>, I>>(
    object: I,
  ): GetCurrentUserResponse {
    const message = createBaseGetCurrentUserResponse();
    message.user =
      object.user !== undefined && object.user !== null
        ? UserInfo.fromPartial(object.user)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseGetUserByIdResponse(): GetUserByIdResponse {
  return { user: undefined, error: undefined };
}

export const GetUserByIdResponse: MessageFns<GetUserByIdResponse> = {
  encode(message: GetUserByIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserByIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserByIdResponse {
    return {
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetUserByIdResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserByIdResponse>, I>>(base?: I): GetUserByIdResponse {
    return GetUserByIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserByIdResponse>, I>>(
    object: I,
  ): GetUserByIdResponse {
    const message = createBaseGetUserByIdResponse();
    message.user =
      object.user !== undefined && object.user !== null
        ? UserInfo.fromPartial(object.user)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseBlockUserRequest(): BlockUserRequest {
  return { userId: '' };
}

export const BlockUserRequest: MessageFns<BlockUserRequest> = {
  encode(message: BlockUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : '' };
  },

  toJSON(message: BlockUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserRequest>, I>>(base?: I): BlockUserRequest {
    return BlockUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserRequest>, I>>(object: I): BlockUserRequest {
    const message = createBaseBlockUserRequest();
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseUnBlockUserRequest(): UnBlockUserRequest {
  return { userId: '' };
}

export const UnBlockUserRequest: MessageFns<UnBlockUserRequest> = {
  encode(message: UnBlockUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnBlockUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnBlockUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : '' };
  },

  toJSON(message: UnBlockUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnBlockUserRequest>, I>>(base?: I): UnBlockUserRequest {
    return UnBlockUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnBlockUserRequest>, I>>(object: I): UnBlockUserRequest {
    const message = createBaseUnBlockUserRequest();
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseBlockUserResponse(): BlockUserResponse {
  return { success: undefined, error: undefined };
}

export const BlockUserResponse: MessageFns<BlockUserResponse> = {
  encode(message: BlockUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      BlockUserSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = BlockUserSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserResponse {
    return {
      success: isSet(object.success) ? BlockUserSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BlockUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = BlockUserSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserResponse>, I>>(base?: I): BlockUserResponse {
    return BlockUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserResponse>, I>>(object: I): BlockUserResponse {
    const message = createBaseBlockUserResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? BlockUserSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseUnBlockUserResponse(): UnBlockUserResponse {
  return { success: undefined, error: undefined };
}

export const UnBlockUserResponse: MessageFns<UnBlockUserResponse> = {
  encode(message: UnBlockUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      UnBlockUserSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnBlockUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnBlockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = UnBlockUserSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnBlockUserResponse {
    return {
      success: isSet(object.success) ? UnBlockUserSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: UnBlockUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = UnBlockUserSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnBlockUserResponse>, I>>(base?: I): UnBlockUserResponse {
    return UnBlockUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnBlockUserResponse>, I>>(
    object: I,
  ): UnBlockUserResponse {
    const message = createBaseUnBlockUserResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? UnBlockUserSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseBlockUserSuccess(): BlockUserSuccess {
  return { updated: false };
}

export const BlockUserSuccess: MessageFns<BlockUserSuccess> = {
  encode(message: BlockUserSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: BlockUserSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserSuccess>, I>>(base?: I): BlockUserSuccess {
    return BlockUserSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserSuccess>, I>>(object: I): BlockUserSuccess {
    const message = createBaseBlockUserSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

function createBaseUnBlockUserSuccess(): UnBlockUserSuccess {
  return { updated: false };
}

export const UnBlockUserSuccess: MessageFns<UnBlockUserSuccess> = {
  encode(message: UnBlockUserSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnBlockUserSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnBlockUserSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnBlockUserSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: UnBlockUserSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnBlockUserSuccess>, I>>(base?: I): UnBlockUserSuccess {
    return UnBlockUserSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnBlockUserSuccess>, I>>(object: I): UnBlockUserSuccess {
    const message = createBaseUnBlockUserSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

function createBaseGetAllInstructorsRequest(): GetAllInstructorsRequest {
  return { pagination: undefined };
}

export const GetAllInstructorsRequest: MessageFns<GetAllInstructorsRequest> = {
  encode(
    message: GetAllInstructorsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllInstructorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllInstructorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllInstructorsRequest {
    return {
      pagination: isSet(object.pagination)
        ? PaginationRequest.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: GetAllInstructorsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllInstructorsRequest>, I>>(
    base?: I,
  ): GetAllInstructorsRequest {
    return GetAllInstructorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllInstructorsRequest>, I>>(
    object: I,
  ): GetAllInstructorsRequest {
    const message = createBaseGetAllInstructorsRequest();
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PaginationRequest.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

function createBaseGetAllInstructorsResponse(): GetAllInstructorsResponse {
  return { success: undefined, error: undefined };
}

export const GetAllInstructorsResponse: MessageFns<GetAllInstructorsResponse> = {
  encode(
    message: GetAllInstructorsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== undefined) {
      AllInstructorsSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllInstructorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllInstructorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AllInstructorsSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllInstructorsResponse {
    return {
      success: isSet(object.success) ? AllInstructorsSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetAllInstructorsResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AllInstructorsSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllInstructorsResponse>, I>>(
    base?: I,
  ): GetAllInstructorsResponse {
    return GetAllInstructorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllInstructorsResponse>, I>>(
    object: I,
  ): GetAllInstructorsResponse {
    const message = createBaseGetAllInstructorsResponse();
    message.success =
      object.success !== undefined && object.success !== null
        ? AllInstructorsSuccess.fromPartial(object.success)
        : undefined;
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    return message;
  },
};

function createBaseAllInstructorsSuccess(): AllInstructorsSuccess {
  return { instructors: [], pagination: undefined };
}

export const AllInstructorsSuccess: MessageFns<AllInstructorsSuccess> = {
  encode(message: AllInstructorsSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instructors) {
      UserInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllInstructorsSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllInstructorsSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instructors.push(UserInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllInstructorsSuccess {
    return {
      instructors: globalThis.Array.isArray(object?.instructors)
        ? object.instructors.map((e: any) => UserInfo.fromJSON(e))
        : [],
      pagination: isSet(object.pagination)
        ? PaginationResponse.fromJSON(object.pagination)
        : undefined,
    };
  },

  toJSON(message: AllInstructorsSuccess): unknown {
    const obj: any = {};
    if (message.instructors?.length) {
      obj.instructors = message.instructors.map((e) => UserInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllInstructorsSuccess>, I>>(base?: I): AllInstructorsSuccess {
    return AllInstructorsSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllInstructorsSuccess>, I>>(
    object: I,
  ): AllInstructorsSuccess {
    const message = createBaseAllInstructorsSuccess();
    message.instructors = object.instructors?.map((e) => UserInfo.fromPartial(e)) || [];
    message.pagination =
      object.pagination !== undefined && object.pagination !== null
        ? PaginationResponse.fromPartial(object.pagination)
        : undefined;
    return message;
  },
};

export type UserServiceService = typeof UserServiceService;
export const UserServiceService = {
  /** User Registration */
  registerUser: {
    path: '/user_service.UserService/RegisterUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterUserRequest) =>
      Buffer.from(RegisterUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegisterUserRequest.decode(value),
    responseSerialize: (value: RegisterUserResponse) =>
      Buffer.from(RegisterUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RegisterUserResponse.decode(value),
  },
  /** Auth2 Sign */
  auth2Sign: {
    path: '/user_service.UserService/Auth2Sign',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Auth2SignRequest) =>
      Buffer.from(Auth2SignRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Auth2SignRequest.decode(value),
    responseSerialize: (value: Auth2SignResponse) =>
      Buffer.from(Auth2SignResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Auth2SignResponse.decode(value),
  },
  verifyUser: {
    path: '/user_service.UserService/VerifyUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyUserRequest) =>
      Buffer.from(VerifyUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyUserRequest.decode(value),
    responseSerialize: (value: VerifyUserResponse) =>
      Buffer.from(VerifyUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyUserResponse.decode(value),
  },
  /** User Login */
  loginUser: {
    path: '/user_service.UserService/LoginUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginUserRequest) =>
      Buffer.from(LoginUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LoginUserRequest.decode(value),
    responseSerialize: (value: LoginUserResponse) =>
      Buffer.from(LoginUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LoginUserResponse.decode(value),
  },
  /** Logout User */
  logoutUser: {
    path: '/user_service.UserService/LogoutUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LogoutUserRequest) =>
      Buffer.from(LogoutUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LogoutUserRequest.decode(value),
    responseSerialize: (value: LogoutUserResponse) =>
      Buffer.from(LogoutUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LogoutUserResponse.decode(value),
  },
  /** Get New Refresh Token */
  getRefreshToken: {
    path: '/user_service.UserService/GetRefreshToken',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRefreshTokenRequest) =>
      Buffer.from(GetRefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetRefreshTokenRequest.decode(value),
    responseSerialize: (value: GetRefreshTokenResponse) =>
      Buffer.from(GetRefreshTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetRefreshTokenResponse.decode(value),
  },
  /** Get New Refresh Token */
  registerInstructor: {
    path: '/user_service.UserService/RegisterInstructor',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterInstructorRequest) =>
      Buffer.from(RegisterInstructorRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegisterInstructorRequest.decode(value),
    responseSerialize: (value: RegisterInstructorResponse) =>
      Buffer.from(RegisterInstructorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RegisterInstructorResponse.decode(value),
  },
  /** Forgot Password */
  forgotPassword: {
    path: '/user_service.UserService/ForgotPassword',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest) =>
      Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: ForgotPasswordResponse) =>
      Buffer.from(ForgotPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ForgotPasswordResponse.decode(value),
  },
  /** Update User Details */
  updateUserDetails: {
    path: '/user_service.UserService/UpdateUserDetails',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateUserDetailsRequest) =>
      Buffer.from(UpdateUserDetailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateUserDetailsRequest.decode(value),
    responseSerialize: (value: UpdateUserDetailsResponse) =>
      Buffer.from(UpdateUserDetailsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateUserDetailsResponse.decode(value),
  },
  /** Change Password */
  changePassword: {
    path: '/user_service.UserService/ChangePassword',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChangePasswordRequest) =>
      Buffer.from(ChangePasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChangePasswordRequest.decode(value),
    responseSerialize: (value: ChangePasswordResponse) =>
      Buffer.from(ChangePasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ChangePasswordResponse.decode(value),
  },
  /** Get Wallet Transactions for a User (with pagination) */
  getWalletTransactions: {
    path: '/user_service.UserService/GetWalletTransactions',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWalletTransactionsRequest) =>
      Buffer.from(GetWalletTransactionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWalletTransactionsRequest.decode(value),
    responseSerialize: (value: GetWalletTransactionsResponse) =>
      Buffer.from(GetWalletTransactionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWalletTransactionsResponse.decode(value),
  },
  /** Get All Users (with pagination) */
  getAllUsers: {
    path: '/user_service.UserService/GetAllUsers',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllUsersRequest) =>
      Buffer.from(GetAllUsersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllUsersRequest.decode(value),
    responseSerialize: (value: GetAllUsersResponse) =>
      Buffer.from(GetAllUsersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllUsersResponse.decode(value),
  },
  /** Get All Users emails */
  getAllUserEmails: {
    path: '/user_service.UserService/GetAllUserEmails',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllUserEmailsRequest) =>
      Buffer.from(GetAllUserEmailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllUserEmailsRequest.decode(value),
    responseSerialize: (value: GetAllUserEmailsResponse) =>
      Buffer.from(GetAllUserEmailsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllUserEmailsResponse.decode(value),
  },
  /** Get All Users emails */
  checkUserEmailExist: {
    path: '/user_service.UserService/CheckUserEmailExist',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckUserByEmailRequest) =>
      Buffer.from(CheckUserByEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckUserByEmailRequest.decode(value),
    responseSerialize: (value: CheckUserByEmailResponse) =>
      Buffer.from(CheckUserByEmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckUserByEmailResponse.decode(value),
  },
  /** Get Details About a Particular User by ID */
  getUserById: {
    path: '/user_service.UserService/GetUserById',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserByIdRequest) =>
      Buffer.from(GetUserByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserByIdRequest.decode(value),
    responseSerialize: (value: GetUserByIdResponse) =>
      Buffer.from(GetUserByIdResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUserByIdResponse.decode(value),
  },
  /** // Get Details About the currently logged in User */
  getCurrentUser: {
    path: '/user_service.UserService/GetCurrentUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCurrentUserRequest) =>
      Buffer.from(GetCurrentUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetCurrentUserRequest.decode(value),
    responseSerialize: (value: GetCurrentUserResponse) =>
      Buffer.from(GetCurrentUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCurrentUserResponse.decode(value),
  },
  /** Block/Unblock a User */
  blockUser: {
    path: '/user_service.UserService/BlockUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockUserRequest) =>
      Buffer.from(BlockUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockUserRequest.decode(value),
    responseSerialize: (value: BlockUserResponse) =>
      Buffer.from(BlockUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockUserResponse.decode(value),
  },
  /** Block/Unblock a User */
  unBlockUser: {
    path: '/user_service.UserService/UnBlockUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnBlockUserRequest) =>
      Buffer.from(UnBlockUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UnBlockUserRequest.decode(value),
    responseSerialize: (value: UnBlockUserResponse) =>
      Buffer.from(UnBlockUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UnBlockUserResponse.decode(value),
  },
  getDetailedUser: {
    path: '/user_service.UserService/GetDetailedUser',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDetailedUserRequest) =>
      Buffer.from(GetDetailedUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetDetailedUserRequest.decode(value),
    responseSerialize: (value: GetDetailedUserResponse) =>
      Buffer.from(GetDetailedUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetDetailedUserResponse.decode(value),
  },
  /** Get All Instructors (with pagination) */
  getAllInstructors: {
    path: '/user_service.UserService/GetAllInstructors',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllInstructorsRequest) =>
      Buffer.from(GetAllInstructorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllInstructorsRequest.decode(value),
    responseSerialize: (value: GetAllInstructorsResponse) =>
      Buffer.from(GetAllInstructorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllInstructorsResponse.decode(value),
  },
} as const;

export interface UserServiceServer extends UntypedServiceImplementation {
  /** User Registration */
  registerUser: handleUnaryCall<RegisterUserRequest, RegisterUserResponse>;
  /** Auth2 Sign */
  auth2Sign: handleUnaryCall<Auth2SignRequest, Auth2SignResponse>;
  verifyUser: handleUnaryCall<VerifyUserRequest, VerifyUserResponse>;
  /** User Login */
  loginUser: handleUnaryCall<LoginUserRequest, LoginUserResponse>;
  /** Logout User */
  logoutUser: handleUnaryCall<LogoutUserRequest, LogoutUserResponse>;
  /** Get New Refresh Token */
  getRefreshToken: handleUnaryCall<GetRefreshTokenRequest, GetRefreshTokenResponse>;
  /** Get New Refresh Token */
  registerInstructor: handleUnaryCall<RegisterInstructorRequest, RegisterInstructorResponse>;
  /** Forgot Password */
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, ForgotPasswordResponse>;
  /** Update User Details */
  updateUserDetails: handleUnaryCall<UpdateUserDetailsRequest, UpdateUserDetailsResponse>;
  /** Change Password */
  changePassword: handleUnaryCall<ChangePasswordRequest, ChangePasswordResponse>;
  /** Get Wallet Transactions for a User (with pagination) */
  getWalletTransactions: handleUnaryCall<
    GetWalletTransactionsRequest,
    GetWalletTransactionsResponse
  >;
  /** Get All Users (with pagination) */
  getAllUsers: handleUnaryCall<GetAllUsersRequest, GetAllUsersResponse>;
  /** Get All Users emails */
  getAllUserEmails: handleUnaryCall<GetAllUserEmailsRequest, GetAllUserEmailsResponse>;
  /** Get All Users emails */
  checkUserEmailExist: handleUnaryCall<CheckUserByEmailRequest, CheckUserByEmailResponse>;
  /** Get Details About a Particular User by ID */
  getUserById: handleUnaryCall<GetUserByIdRequest, GetUserByIdResponse>;
  /** // Get Details About the currently logged in User */
  getCurrentUser: handleUnaryCall<GetCurrentUserRequest, GetCurrentUserResponse>;
  /** Block/Unblock a User */
  blockUser: handleUnaryCall<BlockUserRequest, BlockUserResponse>;
  /** Block/Unblock a User */
  unBlockUser: handleUnaryCall<UnBlockUserRequest, UnBlockUserResponse>;
  getDetailedUser: handleUnaryCall<GetDetailedUserRequest, GetDetailedUserResponse>;
  /** Get All Instructors (with pagination) */
  getAllInstructors: handleUnaryCall<GetAllInstructorsRequest, GetAllInstructorsResponse>;
}

export interface UserServiceClient extends Client {
  /** User Registration */
  registerUser(
    request: RegisterUserRequest,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  /** Auth2 Sign */
  auth2Sign(
    request: Auth2SignRequest,
    callback: (error: ServiceError | null, response: Auth2SignResponse) => void,
  ): ClientUnaryCall;
  auth2Sign(
    request: Auth2SignRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Auth2SignResponse) => void,
  ): ClientUnaryCall;
  auth2Sign(
    request: Auth2SignRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Auth2SignResponse) => void,
  ): ClientUnaryCall;
  verifyUser(
    request: VerifyUserRequest,
    callback: (error: ServiceError | null, response: VerifyUserResponse) => void,
  ): ClientUnaryCall;
  verifyUser(
    request: VerifyUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyUserResponse) => void,
  ): ClientUnaryCall;
  verifyUser(
    request: VerifyUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyUserResponse) => void,
  ): ClientUnaryCall;
  /** User Login */
  loginUser(
    request: LoginUserRequest,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  /** Logout User */
  logoutUser(
    request: LogoutUserRequest,
    callback: (error: ServiceError | null, response: LogoutUserResponse) => void,
  ): ClientUnaryCall;
  logoutUser(
    request: LogoutUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LogoutUserResponse) => void,
  ): ClientUnaryCall;
  logoutUser(
    request: LogoutUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LogoutUserResponse) => void,
  ): ClientUnaryCall;
  /** Get New Refresh Token */
  getRefreshToken(
    request: GetRefreshTokenRequest,
    callback: (error: ServiceError | null, response: GetRefreshTokenResponse) => void,
  ): ClientUnaryCall;
  getRefreshToken(
    request: GetRefreshTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetRefreshTokenResponse) => void,
  ): ClientUnaryCall;
  getRefreshToken(
    request: GetRefreshTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetRefreshTokenResponse) => void,
  ): ClientUnaryCall;
  /** Get New Refresh Token */
  registerInstructor(
    request: RegisterInstructorRequest,
    callback: (error: ServiceError | null, response: RegisterInstructorResponse) => void,
  ): ClientUnaryCall;
  registerInstructor(
    request: RegisterInstructorRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RegisterInstructorResponse) => void,
  ): ClientUnaryCall;
  registerInstructor(
    request: RegisterInstructorRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RegisterInstructorResponse) => void,
  ): ClientUnaryCall;
  /** Forgot Password */
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  /** Update User Details */
  updateUserDetails(
    request: UpdateUserDetailsRequest,
    callback: (error: ServiceError | null, response: UpdateUserDetailsResponse) => void,
  ): ClientUnaryCall;
  updateUserDetails(
    request: UpdateUserDetailsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateUserDetailsResponse) => void,
  ): ClientUnaryCall;
  updateUserDetails(
    request: UpdateUserDetailsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateUserDetailsResponse) => void,
  ): ClientUnaryCall;
  /** Change Password */
  changePassword(
    request: ChangePasswordRequest,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  /** Get Wallet Transactions for a User (with pagination) */
  getWalletTransactions(
    request: GetWalletTransactionsRequest,
    callback: (error: ServiceError | null, response: GetWalletTransactionsResponse) => void,
  ): ClientUnaryCall;
  getWalletTransactions(
    request: GetWalletTransactionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWalletTransactionsResponse) => void,
  ): ClientUnaryCall;
  getWalletTransactions(
    request: GetWalletTransactionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWalletTransactionsResponse) => void,
  ): ClientUnaryCall;
  /** Get All Users (with pagination) */
  getAllUsers(
    request: GetAllUsersRequest,
    callback: (error: ServiceError | null, response: GetAllUsersResponse) => void,
  ): ClientUnaryCall;
  getAllUsers(
    request: GetAllUsersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllUsersResponse) => void,
  ): ClientUnaryCall;
  getAllUsers(
    request: GetAllUsersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllUsersResponse) => void,
  ): ClientUnaryCall;
  /** Get All Users emails */
  getAllUserEmails(
    request: GetAllUserEmailsRequest,
    callback: (error: ServiceError | null, response: GetAllUserEmailsResponse) => void,
  ): ClientUnaryCall;
  getAllUserEmails(
    request: GetAllUserEmailsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllUserEmailsResponse) => void,
  ): ClientUnaryCall;
  getAllUserEmails(
    request: GetAllUserEmailsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllUserEmailsResponse) => void,
  ): ClientUnaryCall;
  /** Get All Users emails */
  checkUserEmailExist(
    request: CheckUserByEmailRequest,
    callback: (error: ServiceError | null, response: CheckUserByEmailResponse) => void,
  ): ClientUnaryCall;
  checkUserEmailExist(
    request: CheckUserByEmailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckUserByEmailResponse) => void,
  ): ClientUnaryCall;
  checkUserEmailExist(
    request: CheckUserByEmailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckUserByEmailResponse) => void,
  ): ClientUnaryCall;
  /** Get Details About a Particular User by ID */
  getUserById(
    request: GetUserByIdRequest,
    callback: (error: ServiceError | null, response: GetUserByIdResponse) => void,
  ): ClientUnaryCall;
  getUserById(
    request: GetUserByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUserByIdResponse) => void,
  ): ClientUnaryCall;
  getUserById(
    request: GetUserByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUserByIdResponse) => void,
  ): ClientUnaryCall;
  /** // Get Details About the currently logged in User */
  getCurrentUser(
    request: GetCurrentUserRequest,
    callback: (error: ServiceError | null, response: GetCurrentUserResponse) => void,
  ): ClientUnaryCall;
  getCurrentUser(
    request: GetCurrentUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCurrentUserResponse) => void,
  ): ClientUnaryCall;
  getCurrentUser(
    request: GetCurrentUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCurrentUserResponse) => void,
  ): ClientUnaryCall;
  /** Block/Unblock a User */
  blockUser(
    request: BlockUserRequest,
    callback: (error: ServiceError | null, response: BlockUserResponse) => void,
  ): ClientUnaryCall;
  blockUser(
    request: BlockUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockUserResponse) => void,
  ): ClientUnaryCall;
  blockUser(
    request: BlockUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockUserResponse) => void,
  ): ClientUnaryCall;
  /** Block/Unblock a User */
  unBlockUser(
    request: UnBlockUserRequest,
    callback: (error: ServiceError | null, response: UnBlockUserResponse) => void,
  ): ClientUnaryCall;
  unBlockUser(
    request: UnBlockUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UnBlockUserResponse) => void,
  ): ClientUnaryCall;
  unBlockUser(
    request: UnBlockUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UnBlockUserResponse) => void,
  ): ClientUnaryCall;
  getDetailedUser(
    request: GetDetailedUserRequest,
    callback: (error: ServiceError | null, response: GetDetailedUserResponse) => void,
  ): ClientUnaryCall;
  getDetailedUser(
    request: GetDetailedUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetDetailedUserResponse) => void,
  ): ClientUnaryCall;
  getDetailedUser(
    request: GetDetailedUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetDetailedUserResponse) => void,
  ): ClientUnaryCall;
  /** Get All Instructors (with pagination) */
  getAllInstructors(
    request: GetAllInstructorsRequest,
    callback: (error: ServiceError | null, response: GetAllInstructorsResponse) => void,
  ): ClientUnaryCall;
  getAllInstructors(
    request: GetAllInstructorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllInstructorsResponse) => void,
  ): ClientUnaryCall;
  getAllInstructors(
    request: GetAllInstructorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllInstructorsResponse) => void,
  ): ClientUnaryCall;
}

export const UserServiceClient = makeGenericClientConstructor(
  UserServiceService,
  'user_service.UserService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): UserServiceClient;
  service: typeof UserServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === 'string') {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
